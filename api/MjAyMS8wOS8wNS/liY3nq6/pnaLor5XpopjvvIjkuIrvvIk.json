{"title":"前端面试题（上）","date":"2021-09-05T08:52:29.000Z","date_formatted":{"ll":"2021年9月5日","L":"2021/09/05","MM-DD":"09-05"},"thumbnail":"https://i.loli.net/2021/09/05/XlSGQUqhDEmeaHR.jpg","link":"2021/09/05/前端面试题（上）","comments":true,"tags":["CSS","HTML","HTTP/HTTPS","JS"],"categories":["面经"],"updated":"2021-09-05T09:12:43.784Z","content":"<h3 id=\"typeof和instanceof\">typeof和instanceof<a title=\"#typeof和instanceof\" href=\"#typeof和instanceof\"></a></h3>\n<h5 id=\"javascript的数据类型\">Javascript的数据类型<a title=\"#javascript的数据类型\" href=\"#javascript的数据类型\"></a></h5>\n<ul>\n<li>String、Number、Boolean、null、symbol、undefined、Object、bigint（ES20）</li>\n</ul>\n<p>布尔类型里只有这几参数个返回false，其它都为true</p>\n<p>null和undefined在进行“==”比较是不会进行类型转换<br>\nBoolean(undefined) // false</p>\n<p>Boolean(null) // false</p>\n<p>Boolean(0) // false</p>\n<p>Boolean(NaN) // false</p>\n<p>Boolean(‘’) // false</p>\n<p>Boolean([]); //true</p>\n<p>Number([]); //0</p>\n<p>Number({}); // NaN</p>\n<p>Number(false); //0</p>\n<p>但是  []==false //true<br>\nnull&gt;=0//true</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(null&gt;=0);//true  特殊****</span><br><span class=\"line\">console.log(null&gt;0);//false</span><br><span class=\"line\">console.log(null==0);//false</span><br><span class=\"line\">console.log(&#123;&#125;==false);//false</span><br><span class=\"line\">console.log(&#123;&#125;==true);//false</span><br><span class=\"line\">console.log(1==true);//true</span><br><span class=\"line\">console.log(2==true);//false</span><br></pre></td></tr></table></figure>\n<p>“==”运算符（两个操作数的类型不相同时）<br>\n如果一个值是null，另一个值是undefined，则它们相等<br>\n如果一个值是数字，另一个值是字符串，先将字符串转换为数学，然后使用转换后的值进行比较。<br>\n如果其中一个值是true，则将其转换为1再进行比较。如果其中的一个值是false，则将其转换为0再进行比较。<br>\n如果一个值是对象，另一个值是数字或字符串，则将对象转换为原始值，再进行比较。</p>\n<h5 id=\"typeof\">typeof<a title=\"#typeof\" href=\"#typeof\"></a></h5>\n<ul>\n<li>\n<p>用于判断数据类型，返回值为7个字符串，分别为string、Boolean、number、function、object、undefined symbol。</p>\n</li>\n<li>\n<p>typeof对于丰富的对象实例（null，array ，object），只能返回&quot;Object&quot;字符串</p>\n</li>\n</ul>\n<h5 id=\"instanceof\">instanceof<a title=\"#instanceof\" href=\"#instanceof\"></a></h5>\n<p>判断该对象是谁的实例，基于原型链判断，（A instanceof B）返回的是boolean类型，同时instanceof是对象运算符。</p>\n<h3 id=\"spa和ssr的区别\">spa和ssr的区别<a title=\"#spa和ssr的区别\" href=\"#spa和ssr的区别\"></a></h3>\n<h5 id=\"什么是单页面应用（spa）？\">什么是单页面应用（SPA）？<a title=\"#什么是单页面应用（spa）？\" href=\"#什么是单页面应用（spa）？\"></a></h5>\n<p>概念：整个web项目只有一个页面，使用路由机制进行组件之间的切换；</p>\n<p>优点：客户端渲染、数据传输量小、减少服务器端压力、交互/响应速度快、前后端完全分离；</p>\n<p>缺点：首屏加载慢、对SEO不友好，不利于百度，360等搜索引擎收录快照；</p>\n<h5 id=\"什么是服务端渲染（ssr）？\">什么是服务端渲染（SSR）？<a title=\"#什么是服务端渲染（ssr）？\" href=\"#什么是服务端渲染（ssr）？\"></a></h5>\n<p>概念：将组件或页面通过服务器端生成HTML字符串，再发送到浏览器端渲染；</p>\n<p>优点：对于SEO友好、首屏加载速度快；</p>\n<p>缺点：页面重复加载次数高、开发效率低、数据传输量大、服务器压力大；</p>\n<h5 id=\"spa、ssr分别适合什么样的应用场景？\">SPA、SSR分别适合什么样的应用场景？<a title=\"#spa、ssr分别适合什么样的应用场景？\" href=\"#spa、ssr分别适合什么样的应用场景？\"></a></h5>\n<p>SPA：对项目性能要求高、页面加载速度快、要求客户端渲染、对SEO要求低；</p>\n<p>SSR：对项目SEO要求高、首次打开响应速度快；</p>\n<p>在vue中可以用nuxt和vue-server-render</p>\n<h3 id=\"圣杯布局和双飞翼布局的作用和区别\">圣杯布局和双飞翼布局的作用和区别<a title=\"#圣杯布局和双飞翼布局的作用和区别\" href=\"#圣杯布局和双飞翼布局的作用和区别\"></a></h3>\n<p>圣杯布局和双飞翼布局解决的问题是一样的，就是两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。</p>\n<p>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。</p>\n<p>不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：<br>\n圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。</p>\n<p>双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。<br>\n多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，一共6个；而双飞翼布局子div里用margin-left和margin-right共2个属性，6-2=4），个人感觉比圣杯布局思路更直接和简洁一点。</p>\n<p>简单说起来就是”双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了“，而不是你题目中说的”去掉relative&quot;就是双飞翼布局“。</p>\n<p><a href=\"https://www.cnblogs.com/jiguiyan/p/11425276.html\">https://www.cnblogs.com/jiguiyan/p/11425276.html</a></p>\n<h3 id=\"event.target和event.currenttarget\">event.target和event.currentTarget<a title=\"#event.target和event.currenttarget\" href=\"#event.target和event.currenttarget\"></a></h3>\n<p>event.target 获取的是触发事件的标签元素（比如事件委托）</p>\n<p>event.currentTarget 获取到的是发起事件的标签元素（始终返回的是绑定事件的元素）</p>\n<h3 id=\"xhtml和html的区别\">XHTML和html的区别<a title=\"#xhtml和html的区别\" href=\"#xhtml和html的区别\"></a></h3>\n<h5 id=\"文档结构\">文档结构<a title=\"#文档结构\" href=\"#文档结构\"></a></h5>\n<ul>\n<li>XHTML DOCTYPE 是强制性的</li>\n<li>html 中的 XML namespace 属性是强制性的</li>\n<li>html、head、title 以及 body 也是强制性的</li>\n</ul>\n<h5 id=\"元素语法\">元素语法<a title=\"#元素语法\" href=\"#元素语法\"></a></h5>\n<ul>\n<li>XHTML 元素必须正确嵌套</li>\n<li>XHTML 元素必须始终关闭</li>\n<li>XHTML 元素必须小写</li>\n<li>XHTML 文档必须有一个根元素</li>\n</ul>\n<h5 id=\"属性语法\">属性语法<a title=\"#属性语法\" href=\"#属性语法\"></a></h5>\n<ul>\n<li>XHTML 属性必须使用小写</li>\n<li>XHTML 属性值必须用引号包围</li>\n<li>XHTML 属性最小化也是禁止的</li>\n</ul>\n<h3 id=\"事件模型\">事件模型<a title=\"#事件模型\" href=\"#事件模型\"></a></h3>\n<h5 id=\"原始事件模型\">原始事件模型<a title=\"#原始事件模型\" href=\"#原始事件模型\"></a></h5>\n<p>这是一种被所有浏览器都支持的事件模型，对于原始事件而言，没有事件流，事件一旦发生将马上进行处理，有两种方式可以实现原始事件：</p>\n<p>（1）在html代码中直接指定属性值：<code>&lt;button id=&quot;demo&quot; type=&quot;button&quot; onclick=&quot;doSomeTing()&quot; /&gt;　　</code></p>\n<p>（2）在js代码中为 <code>　document.getElementsById(&quot;demo&quot;).onclick = doSomeTing()</code></p>\n<p>优点：所有浏览器都兼容</p>\n<p>缺点：1）逻辑与显示没有分离；2）相同事件的监听函数只能绑定一个，后绑定的会覆盖掉前面的，如：a.onclick = func1; a.onclick = func2;将只会执行func2中的内容。3）无法通过事件的冒泡、委托等机制（后面会讲到）完成更多事情。</p>\n<h5 id=\"dom2事件模型\">dom2事件模型<a title=\"#dom2事件模型\" href=\"#dom2事件模型\"></a></h5>\n<p>(1).事件捕获阶段，(2).事件目标阶段，(3).事件冒泡阶段。</p>\n<p>事件捕获：当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。</p>\n<p>事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。</p>\n<p>事件冒泡：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。</p>\n<h5 id=\"事件的传播是可以阻止的：\">事件的传播是可以阻止的：<a title=\"#事件的传播是可以阻止的：\" href=\"#事件的传播是可以阻止的：\"></a></h5>\n<p>• 在W3c中，使用stopPropagation（）方法<br>\n　　• 在IE下设置eve.cancelBubble = true；<br>\n　　在捕获的过程中stopPropagation（）；后，后面的冒泡过程就不会发生了。</p>\n<h3 id=\"git的基本使用\">git的基本使用<a title=\"#git的基本使用\" href=\"#git的基本使用\"></a></h3>\n<p>在powershell中安装可以使用git命令之后</p>\n<ul>\n<li>git init 初始化仓库</li>\n<li>git status 展示状态</li>\n</ul>\n<p>如果出现please tell me who are you则需要执行下面两条命令</p>\n<p>2.git config <a href=\"http://user.name\">user.name</a> “someone”</p>\n<p>3.git config user.email “<a href=\"mailto:someone@someplace.com\">someone@someplace.com</a>”</p>\n<ul>\n<li>\n<p>git add . 将所有文件放到暂存区</p>\n</li>\n<li>\n<p>git commit -m “init my project”  提交项目到本地git</p>\n</li>\n<li>\n<p>git remote add origin <a href=\"https://github.com/WLJ456/Vue.git\">https://github.com/WLJ456/Vue.git</a>   远程连接github账号</p>\n</li>\n<li>\n<p>git push -u origin master  上传项目到github。输入账号密码之后即可上传。</p>\n</li>\n<li>\n<p>修改之后不用在运行git 命令 直接使用vscode自带功能暂存到本地，并推送到github</p>\n</li>\n<li>\n<p>克隆获取代码：git clone -b main  <a href=\"https://github.com/WLJ456/blogVue.git\">https://github.com/WLJ456/blogVue.git</a> F:\\asus\\Desktop\\gitsave   注意 -b是获取其他分支的方式，如果没有-b则获取默认分支。</p>\n</li>\n<li>\n<p>git branch text //创建 text分支</p>\n</li>\n<li>\n<p>git checkout text //切换到 text分支</p>\n</li>\n<li>\n<p>git push --set-upstream origin text //text分支已经上传到了 github</p>\n</li>\n</ul>\n<h5 id=\"vscode-本身自带-点击源代码管理可进行一定操作\">Vscode 本身自带 点击源代码管理可进行一定操作<a title=\"#vscode-本身自带-点击源代码管理可进行一定操作\" href=\"#vscode-本身自带-点击源代码管理可进行一定操作\"></a></h5>\n<p>将分支进行合并：</p>\n<p>1.先切换到主分支 git checkout master</p>\n<p>2.在主分支上进行合并git merge text</p>\n<p>3.如有改动的界面，会弹出界面</p>\n<p>4.最后git push推送到远程分支）</p>\n<p><a href=\"https://www.runoob.com/git/git-basic-operations.html\" target=\"_blank\">git基本操作链接</a></p>\n<h3 id=\"webpack模块热替换\">webpack模块热替换<a title=\"#webpack模块热替换\" href=\"#webpack模块热替换\"></a></h3>\n<p>模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面</p>\n<h5 id=\"在应用程序中,通过以下步骤，可以做到在应用程序中置换(swap-in-and-out)模块：\">在应用程序中,通过以下步骤，可以做到在应用程序中置换(swap in and out)模块：<a title=\"#在应用程序中,通过以下步骤，可以做到在应用程序中置换(swap-in-and-out)模块：\" href=\"#在应用程序中,通过以下步骤，可以做到在应用程序中置换(swap-in-and-out)模块：\"></a></h5>\n<ul>\n<li>应用程序代码要求 HMR runtime 检查更新。</li>\n<li>HMR runtime（异步）下载更新，然后通知应用程序代码。</li>\n<li>应用程序代码要求 HMR runtime 应用更新。</li>\n<li>HMR runtime（同步）应用更新。</li>\n<li>你可以设置 HMR，以使此进程自动触发更新，或者你可以选择要求在用户交互时进行更新。</li>\n</ul>\n<h3 id=\"一、event-loop-事件循环：\">一、event loop 事件循环：<a title=\"#一、event-loop-事件循环：\" href=\"#一、event-loop-事件循环：\"></a></h3>\n<h5 id=\"浏览器-eventloop\">浏览器 eventloop<a title=\"#浏览器-eventloop\" href=\"#浏览器-eventloop\"></a></h5>\n<ul>\n<li>eventloop事件循环是一种执行模型一种运行机制，在不同的地方有不同的实现，主要分为浏览器的event loop和nodejs的event loop；在事件循环中有两个重要的概念，宏队列和微队列</li>\n<li>首先，对于浏览器的event loop来说，是html5定义的规范，但是是在浏览器实现的，在浏览器中：宏队列主要包括settimeout和setinterval，微队列主要有promise。主要执行过程是：</li>\n<li>浏览器首先会将同步任务执行完毕，这时调用栈会被清空</li>\n<li>之后会从微任务队列中取出位于队首的回调任务，遵从先进先出的原则依次放入调用栈中执行，直到栈空，如果此时回调函数中又生成了微任务，将其放在队尾等待调用</li>\n<li>当微任务队列为空的时候，这时将调用宏队列，将队首任务放入调用栈执行；（一次只能执行一个宏队列）如果宏任务中产生了微任务，就去先调用微任务，再去调用下一个宏任务</li>\n<li>然后重复步骤，这就是浏览器的eventloop</li>\n</ul>\n<h5 id=\"nodejs-eventloop\">nodejs eventloop<a title=\"#nodejs-eventloop\" href=\"#nodejs-eventloop\"></a></h5>\n<p>nodejs的eventloop是基于libuv实现的，在事件循环执行宏队列时，nodejs的回调任务有6个阶段，timer（settimeout和setinterval）、I/O callback阶段、idle，prepare阶段、poll阶段、check阶段、close 阶段。这6个阶段构成了4个宏队列分别是：Timers Queue、IO Callback Queue、Check Queue、close callback Queue；</p>\n<p>-nodejs 事件循环和浏览器事件循环最主要的区别就是：浏览器可以看做一个宏队列一个微队列；而nodejs是4个宏队列和2个队列，所以就会有队列的执行先后问题，在微队列中首先会执行NextTick Queue（process.nexttick） 在执行传统的微队列比如promise等，在执行宏队列任务时，需要将每一类宏队列的任务全部执行完毕，才执行对应产生的微队列。</p>\n<h3 id=\"二、浏览器缓存：强缓存和协商缓存\">二、浏览器缓存：强缓存和协商缓存<a title=\"#二、浏览器缓存：强缓存和协商缓存\" href=\"#二、浏览器缓存：强缓存和协商缓存\"></a></h3>\n<p>HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。<br>\n浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。<br>\n报文信息主要分为两部分<br>\n1.包含属性的首部(header)————————–附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中<br>\n2.包含数据的主体部分(body)———————–HTTP请求真正想要传输的部分</p>\n<h5 id=\"强缓存\">强缓存<a title=\"#强缓存\" href=\"#强缓存\"></a></h5>\n<p>当我在没有缓存，第一次请求服务器的时候，服务器会将数据和缓存规则一并返回，缓存规则存放在响应头中，  主要是Expires/Cache-Control来表明缓存失效规则，因为在expires中缓存到期时间是服务器的时间，而客户端和服务器的时间可能存在差异，所以先在基本上都使用的cache-control，强缓存主要设置max-age属性，即到期时间，在这个期间客户端访问数据均走缓存</p>\n<h5 id=\"协商缓存\">协商缓存<a title=\"#协商缓存\" href=\"#协商缓存\"></a></h5>\n<p>在第一次请求服务器时，服务器会返回资源，并且返回一个资源的缓存标识，一起存到浏览器的缓存数据库。</p>\n<p>当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后判断标识是否匹配，</p>\n<p>如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器；</p>\n<p>如果缓存标识匹配，表示资源没有更新，并且返回 304 状态码，浏览器就读取本地缓存服务器中的数据。<br>\n在学号是协商缓存中主要有：<br>\nlast-Modified/If-Modified-Since ：服务器返回的资源最后修改时间</p>\n<p>etag/if-none-match：资源在服务器的唯一标识</p>\n<h3 id=\"重绘和重排\">重绘和重排<a title=\"#重绘和重排\" href=\"#重绘和重排\"></a></h3>\n<ul>\n<li>当dom的变化引发了元素几何属性的改变，比如元素的高宽，元素位置啊，导致浏览器重新计算元素的几何属性，并重新构建渲染树，这个过程称为重排</li>\n<li>完成重排后，要将构建的渲染树渲染到屏幕，这个过程叫重绘</li>\n<li>简单来说，重排负责元素的几何属性，而重绘负责元素样式更新，重排必定带来重绘</li>\n</ul>\n<p>重排触发机制：</p>\n<ul>\n<li>添加或者删除可见dom</li>\n<li>元素位置</li>\n<li>元素本身尺寸</li>\n<li>内容改变</li>\n<li>页面渲染器初始化</li>\n</ul>\n<p>优化：虚拟dom和mvvm</p>\n<h3 id=\"三、节流和防抖\">三、节流和防抖<a title=\"#三、节流和防抖\" href=\"#三、节流和防抖\"></a></h3>\n<h5 id=\"防抖：对于短时间内，连续出发的事件，防抖的含义是让某个时间限内，事件处理函数只执行最后一次或最开始的第一次。（如果在期限内又被触发，则会重新计时）\">防抖：对于短时间内，连续出发的事件，防抖的含义是让某个时间限内，事件处理函数只执行最后一次或最开始的第一次。（如果在期限内又被触发，则会重新计时）<a title=\"#防抖：对于短时间内，连续出发的事件，防抖的含义是让某个时间限内，事件处理函数只执行最后一次或最开始的第一次。（如果在期限内又被触发，则会重新计时）\" href=\"#防抖：对于短时间内，连续出发的事件，防抖的含义是让某个时间限内，事件处理函数只执行最后一次或最开始的第一次。（如果在期限内又被触发，则会重新计时）\"></a></h5>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//实现防抖函数</span><br><span class=\"line\">        function debounce(fn, timer) &#123;</span><br><span class=\"line\">            let time = null;</span><br><span class=\"line\">            return function () &#123;</span><br><span class=\"line\">            var context = this, agrs = arguments;</span><br><span class=\"line\">                if (time) &#123;</span><br><span class=\"line\">                    clearTimeout(time)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                time = setTimeout(fn.apply(context,agrs), timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>防抖(debounce)</p>\n<p>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</p>\n<p>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</p>\n<h5 id=\"节流：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。\">节流：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。<a title=\"#节流：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。\" href=\"#节流：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。\"></a></h5>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//实线节流函数</span><br><span class=\"line\">       function throttle(fn, timer) &#123;</span><br><span class=\"line\">           let flag = true</span><br><span class=\"line\">           return function () &#123;</span><br><span class=\"line\">            var context = this, agrs = arguments;</span><br><span class=\"line\">               if (!flag) &#123;</span><br><span class=\"line\">                   return false</span><br><span class=\"line\">               &#125; //在一段时间内flag始终为false</span><br><span class=\"line\">               flag = false</span><br><span class=\"line\">               setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                  fn.apply(context, agrs);</span><br><span class=\"line\">                   flag = true;</span><br><span class=\"line\">               &#125;, timer)</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>节流(throttle)</p>\n<p>鼠标不断点击触发，mousedown(单位时间内只触发一次)</p>\n<p>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</p>\n<h3 id=\"三、web-worker\">三、web worker<a title=\"#三、web-worker\" href=\"#三、web-worker\"></a></h3>\n<h5 id=\"web-worker-的作用，就是为-javascript-创造多线程环境，允许主线程创建-worker-线程，将一些任务分配给后者运行。在主线程运行的同时，worker-线程在后台运行，两者互不干扰。等到-worker-线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被-worker-线程负担了，主线程（通常负责-ui-交互）就会很流畅，不会被阻塞或拖慢。\">Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。<a title=\"#web-worker-的作用，就是为-javascript-创造多线程环境，允许主线程创建-worker-线程，将一些任务分配给后者运行。在主线程运行的同时，worker-线程在后台运行，两者互不干扰。等到-worker-线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被-worker-线程负担了，主线程（通常负责-ui-交互）就会很流畅，不会被阻塞或拖慢。\" href=\"#web-worker-的作用，就是为-javascript-创造多线程环境，允许主线程创建-worker-线程，将一些任务分配给后者运行。在主线程运行的同时，worker-线程在后台运行，两者互不干扰。等到-worker-线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被-worker-线程负担了，主线程（通常负责-ui-交互）就会很流畅，不会被阻塞或拖慢。\"></a></h5>\n<p>Web Worker 有以下几个使用注意点。</p>\n<p>（1）同源限制</p>\n<p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>\n<p>（2）DOM 限制</p>\n<p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。</p>\n<p>（3）通信联系</p>\n<p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>\n<p>（4）脚本限制</p>\n<p>Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>\n<p>（5）文件限制</p>\n<p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p>\n<h3 id=\"四、原型链\">四、原型链<a title=\"#四、原型链\" href=\"#四、原型链\"></a></h3>\n<h5 id=\"prototype-在javascript中，每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。\">prototype 在JavaScript中，每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。<a title=\"#prototype-在javascript中，每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。\" href=\"#prototype-在javascript中，每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。\"></a></h5>\n<h5 id=\"proto-这是每个对象(除null外)都会有的属性，叫做__proto__，这个属性会指向该对象的原型。\"><strong>proto</strong> 这是每个对象(除null外)都会有的属性，叫做__proto__，这个属性会指向该对象的原型。<a title=\"#proto-这是每个对象(除null外)都会有的属性，叫做__proto__，这个属性会指向该对象的原型。\" href=\"#proto-这是每个对象(除null外)都会有的属性，叫做__proto__，这个属性会指向该对象的原型。\"></a></h5>\n<ul>\n<li>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止</li>\n<li>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</li>\n</ul>\n<h3 id=\"原型链污染\">原型链污染<a title=\"#原型链污染\" href=\"#原型链污染\"></a></h3>\n<p>原型污染是指将属性注入现有JavaScript语言构造原型（如对象）的能力。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// foo是一个简单的JavaScript对象</span><br><span class=\"line\">let foo = &#123;bar: 1&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// foo.bar 此时为1</span><br><span class=\"line\">console.log(foo.bar)</span><br><span class=\"line\"></span><br><span class=\"line\">// 修改foo的原型（即Object）</span><br><span class=\"line\">foo.__proto__.bar = 2</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于查找顺序的原因，foo.bar仍然是1</span><br><span class=\"line\">console.log(foo.bar)</span><br><span class=\"line\"></span><br><span class=\"line\">// 此时再用Object创建一个空的zoo对象</span><br><span class=\"line\">let zoo = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 查看zoo.bar</span><br><span class=\"line\">console.log(zoo.bar)</span><br><span class=\"line\">最后，虽然zoo是一个空对象&#123;&#125;，但zoo.bar的结果居然是2：</span><br></pre></td></tr></table></figure>\n<p>在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象，所有JavaScript对象通过原型链继承，都会继承Object.prototype上的属性，这种攻击方式就是原型链污染。</p>\n<p>原型链污染主要是因为攻击者可以设置__proto__的值，解决方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x=Object.create(null);</span><br><span class=\"line\">Object.getPrototypeOf(x)==null;//true</span><br><span class=\"line\"></span><br><span class=\"line\">一些不支持Object.create函数的旧的js环境可能支持__proto__属性，对象字面量也支持初始化一个原型链为null的新对象。</span><br><span class=\"line\">var x=&#123;__proto__:null&#125;;</span><br><span class=\"line\">x instanceof Object;//false</span><br></pre></td></tr></table></figure>\n<h3 id=\"五、new一个构造函数的过程\">五、new一个构造函数的过程<a title=\"#五、new一个构造函数的过程\" href=\"#五、new一个构造函数的过程\"></a></h3>\n<ul>\n<li>创建一个新对象，将它的引用赋值给this，继承函数的原型</li>\n<li>通过this将构造函数的属性添加给这个对象</li>\n<li>最后返回这个this指向的新对象，也就是实例</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let newMethods = function (Parent, ...rest) &#123;</span><br><span class=\"line\">    let child = Object.create(Parent.prototype);</span><br><span class=\"line\">    let ruselt = Parent.apply(child, rest)</span><br><span class=\"line\">    return typeof result === &#x27;object&#x27; ? result : child;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const child = newMethods(ssss, &quot;zdd&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"六、promise原理\">六、promise原理<a title=\"#六、promise原理\" href=\"#六、promise原理\"></a></h3>\n<p>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有等主线程任务执行完毕，&quot;任务队列&quot;开始通知主线程，请求执行任务，该任务才会进入主线程执行。</p>\n<ul>\n<li>首先promise解决的异步问题，同时他的应用场景主要是解决回到地狱的问题，promise 可以实现在多个请求发送完成后，再得到或者处理某个结果，</li>\n<li>promise的原理：promise主要三个状态 pending、Fulfilled、rejected，当promise构造函数需要传入一个函数，函数中有两个参数分别是resolve和reject，在promise中有一个then，他的主要功能是当promise对象状态发生改变时执行相应操作，当然promise是基于发布订阅者模式实现的</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function myPromise(constructor) &#123;</span><br><span class=\"line\">    let self = this;</span><br><span class=\"line\">    self.status = &quot;pending&quot;;</span><br><span class=\"line\">    self.value = undefined;</span><br><span class=\"line\">    self.reason = undefined;</span><br><span class=\"line\">    //定义观察数组</span><br><span class=\"line\">    self.onFullfilledArray = []</span><br><span class=\"line\">    self.onRejectedArray = []</span><br><span class=\"line\">    function resolve(value) &#123;</span><br><span class=\"line\">        if (self.status == &quot;pending&quot;) &#123;</span><br><span class=\"line\">            self.value = value;</span><br><span class=\"line\">            self.status = &quot;resolved&quot;</span><br><span class=\"line\">            self.onFullfilledArray.forEach(fn =&gt; &#123;</span><br><span class=\"line\">                fn(self.value)</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function reject(reason) &#123;</span><br><span class=\"line\">        if (self.status == &quot;pending&quot;) &#123;</span><br><span class=\"line\">            self.reason = reason;</span><br><span class=\"line\">            self.status = &quot;rejected&quot;</span><br><span class=\"line\">            self.onRejectedArray.forEach(fn =&gt; &#123;</span><br><span class=\"line\">                fn(self.reason)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        constructor(resolve, reject);</span><br><span class=\"line\">    &#125; catch (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myPromise.prototype.then = function (onFullfilled, onRejected) &#123;</span><br><span class=\"line\">    let self = this;</span><br><span class=\"line\">    switch (self.status) &#123;</span><br><span class=\"line\">        case &quot;pending&quot;:</span><br><span class=\"line\">            self.onFullfilledArray.push(function () &#123;</span><br><span class=\"line\">                onFullfilled(self.value)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            self.onRejectedArray.push(function () &#123;</span><br><span class=\"line\">                onRejected(self.reason)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case &quot;resolved&quot;:</span><br><span class=\"line\">            onFullfilled(self.value);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case &quot;rejected&quot;:</span><br><span class=\"line\">            onRejected(self.reason);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new myPromise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\">    // resolve(222)</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        resolve(222)</span><br><span class=\"line\">    &#125;, 2000)</span><br><span class=\"line\">&#125;).then(data =&gt; &#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"七、content-type\">七、Content-type<a title=\"#七、content-type\" href=\"#七、content-type\"></a></h3>\n<p>服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。</p>\n<h5 id=\"application/x-www-form-urlencoded\">application/x-www-form-urlencoded<a title=\"#application/x-www-form-urlencoded\" href=\"#application/x-www-form-urlencoded\"></a></h5>\n<ul>\n<li>这应该是最常见的 POST 提交数据的方式了。浏览器的原生 <form> 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。</li>\n</ul>\n<h5 id=\"multipart/form-data\">multipart/form-data<a title=\"#multipart/form-data\" href=\"#multipart/form-data\"></a></h5>\n<ul>\n<li>这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 <form> 表单的enctype 等于 multipart/form-data。</li>\n</ul>\n<h5 id=\"application/json\">application/json<a title=\"#application/json\" href=\"#application/json\"></a></h5>\n<ul>\n<li>通过序列化json字符串的方式进行编码,可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。</li>\n</ul>\n<h5 id=\"text/xml\">text/xml<a title=\"#text/xml\" href=\"#text/xml\"></a></h5>\n<ul>\n<li>忽略xml头所指定bai编码du格式而默认采用zhius-ascii编码</li>\n</ul>\n<h3 id=\"八、mouseover和mouseleave的区别\">八、mouseover和mouseleave的区别<a title=\"#八、mouseover和mouseleave的区别\" href=\"#八、mouseover和mouseleave的区别\"></a></h3>\n<ul>\n<li>mouseover：只要鼠标指针移入事件绑定的元素及其子元素，都会触发mouseover事件</li>\n<li>mouseleave：只有鼠标指针移入事件绑定的元素时，才会触发mouseleave事件</li>\n</ul>\n<h3 id=\"九、canvas和svg\">九、canvas和svg<a title=\"#九、canvas和svg\" href=\"#九、canvas和svg\"></a></h3>\n<h5 id=\"一句话总结：都是2d做图，svg是矢量图，canvas是位图。canvas-是逐像素进行渲染的，适合游戏。\">一句话总结：都是2D做图，svg是矢量图，canvas是位图。Canvas 是逐像素进行渲染的，适合游戏。<a title=\"#一句话总结：都是2d做图，svg是矢量图，canvas是位图。canvas-是逐像素进行渲染的，适合游戏。\" href=\"#一句话总结：都是2d做图，svg是矢量图，canvas是位图。canvas-是逐像素进行渲染的，适合游戏。\"></a></h5>\n<h5 id=\"canvas：\">canvas：<a title=\"#canvas：\" href=\"#canvas：\"></a></h5>\n<ul>\n<li>依赖分辨率</li>\n<li>不支持事件处理器</li>\n<li>弱的文本渲染能力</li>\n<li>能够以 .png 或 .jpg 格式保存结果图像</li>\n<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>\n</ul>\n<h5 id=\"svg（可缩放矢量图形）：\">svg（可缩放矢量图形）：<a title=\"#svg（可缩放矢量图形）：\" href=\"#svg（可缩放矢量图形）：\"></a></h5>\n<ul>\n<li>不依赖分辨率</li>\n<li>支持事件处理器</li>\n<li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>\n<li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>\n<li>不适合游戏应用</li>\n</ul>\n<h3 id=\"十、clientheight、offsetheight、scrollheight\">十、clientHeight、offsetHeight、scrollHeight<a title=\"#十、clientheight、offsetheight、scrollheight\" href=\"#十、clientheight、offsetheight、scrollheight\"></a></h3>\n<ul>\n<li>clientHeight：可理解为内部可视区高度，样式的height+上下padding</li>\n<li>offsetHeight：在clientHeight上包含了boder-Width的高度和滚动条</li>\n<li>scrollHeight： 元素内容的实际距离，包括了隐藏部分的内容高度</li>\n<li>clientTop：容器内部相对于容器本身的top偏移，实际就是 上border-width</li>\n<li>offsetTop：距离最近的开启了position定位的元素的距离，若无就是距离body的高度。 offsetTop = top + margin-top + border-top</li>\n<li>scrollTOp：滚动内容被隐藏的高度</li>\n</ul>\n<h3 id=\"十一、线程和进程\">十一、线程和进程<a title=\"#十一、线程和进程\" href=\"#十一、线程和进程\"></a></h3>\n<ul>\n<li>线程：线程是进程的基本执行单元，一个进程中的所有任务都在线程中执行，进程要想执行任务，必须得有线程，进程至少要有一条线程</li>\n<li>进程：进程是指在系统中正在运行的一个应用程序<br>\n每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</li>\n<li>资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。<br>\n一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li>\n<li>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程</li>\n<li>执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>\n线程是处理器调度的基本单位，但是进程不是。</li>\n</ul>\n<h3 id=\"十二、普通函数和箭头函数的区别\">十二、普通函数和箭头函数的区别<a title=\"#十二、普通函数和箭头函数的区别\" href=\"#十二、普通函数和箭头函数的区别\"></a></h3>\n<ul>\n<li>箭头函数是不能用于构造函数的</li>\n<li>箭头函数中的this是指向其上下文中的this，而普通函数中的this指向其调用对象</li>\n<li>箭头函数不能当做generator函数，不能使用yield关键字</li>\n<li>箭头函数没有prototype属性</li>\n<li>箭头函数不绑定arguments，用rest参数…解决</li>\n</ul>\n<h3 id=\"this\">this<a title=\"#this\" href=\"#this\"></a></h3>\n<p>面向对象语言中 this 表示当前对象的一个引用。</p>\n<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>\n<ul>\n<li>在方法中，this 表示该方法所属的对象。</li>\n<li>如果单独使用，this 表示全局对象。</li>\n<li>在函数中，this 表示全局对象。</li>\n<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>\n<li>在事件中，this 表示接收事件的元素。</li>\n<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li>\n</ul>\n<h3 id=\"十三、var-let-const\">十三、var let const<a title=\"#十三、var-let-const\" href=\"#十三、var-let-const\"></a></h3>\n<ul>\n<li>var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。同时存在变量提升</li>\n<li>let定义的变量，同一块级作用域不能重复定义，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。</li>\n<li>const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。</li>\n</ul>\n<p>注：let和const存在暂时性死区，只是创建过程提升，提前访问报错 xx is not defined，这其实是暂时性死区的表现，也就是说只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>\n<h3 id=\"十四、null和undefined的区别\">十四、null和undefined的区别<a title=\"#十四、null和undefined的区别\" href=\"#十四、null和undefined的区别\"></a></h3>\n<h5 id=\"null表示&quot;没有对象&quot;，即该处不应该有值\">null表示&quot;没有对象&quot;，即该处不应该有值<a title=\"#null表示&quot;没有对象&quot;，即该处不应该有值\" href=\"#null表示&quot;没有对象&quot;，即该处不应该有值\"></a></h5>\n<p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>\n<p>（2） 作为对象原型链的终点。</p>\n<h5 id=\"undefined表示&quot;缺少值&quot;，就是此处应该有一个值\">undefined表示&quot;缺少值&quot;，就是此处应该有一个值<a title=\"#undefined表示&quot;缺少值&quot;，就是此处应该有一个值\" href=\"#undefined表示&quot;缺少值&quot;，就是此处应该有一个值\"></a></h5>\n<p>（1）变量被声明了，但没有赋值时，就等于undefined。</p>\n<p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>\n<p>（3）对象没有赋值的属性，该属性的值为undefined。</p>\n<p>（4）函数没有返回值时，默认返回undefined。</p>\n<h3 id=\"十五、json.stingify深拷贝的缺点\">十五、JSON.stingify深拷贝的缺点<a title=\"#十五、json.stingify深拷贝的缺点\" href=\"#十五、json.stingify深拷贝的缺点\"></a></h3>\n<ul>\n<li>如果对象中有时间对象，之后将字符串在返回成对象的时候，时间对象任然是字符串</li>\n<li>如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；</li>\n<li>如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；</li>\n<li>如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null</li>\n<li>JSON.stringify()只能序列化对象的可枚举的自有属性</li>\n</ul>\n<h3 id=\"十六、require和import\">十六、require和import<a title=\"#十六、require和import\" href=\"#十六、require和import\"></a></h3>\n<ul>\n<li>require是commonjs规范引入的，而import是Es6引入的</li>\n<li>require是运行时调用，而import是编译时调用</li>\n<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</li>\n<li>在commom.js 中module.export 之后 导出的值就不能再变化，但是在es6的export中是可以的</li>\n</ul>\n<h3 id=\"十七、常见选择器\">十七、常见选择器<a title=\"#十七、常见选择器\" href=\"#十七、常见选择器\"></a></h3>\n<ul>\n<li>标签选择器</li>\n<li>id选择器</li>\n<li>类选择器</li>\n<li>属性选择器</li>\n<li>通用选择器</li>\n<li>兄弟选择器</li>\n<li>后代选择器</li>\n<li>并集选择器</li>\n</ul>\n<p>important&gt;行内&gt;id&gt;class&gt;标签</p>\n<h3 id=\"十八、clientx/clienty、screenx/screeny、pagex/pagey、offsetx/offsety\">十八、clientX/clientY、screenX/screenY、pageX/pageY、offsetX/offsetY<a title=\"#十八、clientx/clienty、screenx/screeny、pagex/pagey、offsetx/offsety\" href=\"#十八、clientx/clienty、screenx/screeny、pagex/pagey、offsetx/offsety\"></a></h3>\n<ul>\n<li>clientX/clientY：返回事件触发时鼠标相对于元素视口的X/Y坐标 (这里的元素视口实际上代指就是浏览器，clientX是鼠标距离浏览器左边框的距离，clientY是鼠标距离浏览器上边框的距离。)</li>\n<li>screenX/screenY:返回事件触发时鼠标相对于屏幕 的X/Y坐标</li>\n<li>pageX/pageY：返回事件触发时鼠标相对于文档 X和Y坐标</li>\n<li>offsetX/offsetY：返回事件触发时鼠标相对于事件指向元素 的X和Y坐标（假设有一个元素p当鼠标进入元素中触发事件时这是offsetX指的就是鼠标到P元素左边的距离。但是这个属性并不是标准属性，因此IE和chrome对这个属性的支持并不一样。在chrome中offsetX和offsetY的值均为整数，而在IE中值为小数形式，并且如果元素有border属性也会影响到offsetY的计算。）</li>\n</ul>\n<h3 id=\"十九、常见布局方式\">十九、常见布局方式<a title=\"#十九、常见布局方式\" href=\"#十九、常见布局方式\"></a></h3>\n<ul>\n<li>固定布局：pc端常见的px为单位的布局方式，使用于pc端，但不适用于手机端；</li>\n<li>流式布局：也叫百分比布局，具有较好的解决自适应需求，但是缺点就是不够灵活，添加元素时，需要修改其他元素的百分比。</li>\n<li>flex布局：也叫弹性布局，会根据页面剩余的宽度自动分配空间，比较合适应用程序的组件和小规模的布局。</li>\n<li>媒体查询和rem布局：现在比较流行的布局，可以根据不同设备的宽度加载不同的css样式。主要是通过更改不同的font-size大小来更改样式，可以实现移动端的响应式</li>\n<li>响应式布局：主要是通过媒体查询的方式，来执行不同的css代码</li>\n</ul>\n<h3 id=\"二十、resultful的特点\">二十、resultFul的特点<a title=\"#二十、resultful的特点\" href=\"#二十、resultful的特点\"></a></h3>\n<h4 id=\"rest的含义\">rest的含义<a title=\"#rest的含义\" href=\"#rest的含义\"></a></h4>\n<ul>\n<li>每一个url代表的一种资源</li>\n<li>客户端和服务端，是传递这种资源的表现层</li>\n<li>客户端通过http的put、get、post、delete的方式，来进行服务端资源进行操作，从而实现表现层的状态转换</li>\n</ul>\n<h4 id=\"restful的原则\">restful的原则<a title=\"#restful的原则\" href=\"#restful的原则\"></a></h4>\n<ul>\n<li>c-s架构</li>\n<li>无状态 客户端每次需要携带认证信息让服务端识别</li>\n<li>统一的接口 rest架构的核心，统一的接口对于restful服务十分重要，客户端只需要关注实现接口就可以了，接口的可读性加强，使用人员方便调用，</li>\n<li>一致的数据格式 （xml、json、或者返回状态码）</li>\n<li>系统分层和可缓存</li>\n</ul>\n<h3 id=\"二十一、cdn网站加速\">二十一、CDN网站加速<a title=\"#二十一、cdn网站加速\" href=\"#二十一、cdn网站加速\"></a></h3>\n<ul>\n<li>CDN全称叫做内容分发网络，是通过主动加入内容管理层和全局负载均衡，尽可能的避开网络上有可能影响数据传输速度和稳定性的环节；</li>\n<li>cdn网站加速是一种新型的网络构建模式，使用CDN加速之后，远程用户访问会通过负载均衡技术自动选择最快的Cache服务器，由此来缩短访问的响应时延。</li>\n</ul>\n<h5 id=\"cdn优势\">CDN优势<a title=\"#cdn优势\" href=\"#cdn优势\"></a></h5>\n<ul>\n<li>cdn节点解决跨地域和跨运营商的问题，降低了访问时延</li>\n<li>大部分请求都会在CDN边缘节点，CDN可以起到分流的作用，减轻了服务器的压力</li>\n</ul>\n<h5 id=\"cdn的缺点\">CDN的缺点<a title=\"#cdn的缺点\" href=\"#cdn的缺点\"></a></h5>\n<ul>\n<li>当服务器更新资源的时候，如果cdn节点上的数据没有更新，那么用户会出现访问异常（因为cdn更新是具有周期性的，又称回源，可以进行手动刷新cdn的方式）</li>\n</ul>\n<h3 id=\"二十二、js动画和css动画的区别\">二十二、js动画和css动画的区别<a title=\"#二十二、js动画和css动画的区别\" href=\"#二十二、js动画和css动画的区别\"></a></h3>\n<h5 id=\"css动画-（gui解析）\">CSS动画 （GUI解析）<a title=\"#css动画-（gui解析）\" href=\"#css动画-（gui解析）\"></a></h5>\n<ul>\n<li>优点：性能较好，浏览器会对CSS动画做一些优化</li>\n<li>代码相对简单。</li>\n</ul>\n<hr>\n<ul>\n<li>缺点：</li>\n<li>在动画上控制不够灵活；</li>\n<li>兼容性不好；</li>\n<li>部分动画无法实现（如滚动动画，视差滚动等）</li>\n</ul>\n<h5 id=\"javascript动画\">JavaScript动画<a title=\"#javascript动画\" href=\"#javascript动画\"></a></h5>\n<ul>\n<li>控制能力强，动画效果丰富， 可以单帧的控制、变换； - 大部分时候不存在兼容性问题。</li>\n<li>缺点：</li>\n<li>干扰主线程导致阻塞，造成丢帧情况</li>\n<li>代码复杂度高</li>\n</ul>\n<p>CSS动画流畅的原因<br>\n渲染线程分为main thread(主线程)和compositor thread(合成器线程)。<br>\n如果CSS动画只是改变transform和opacity，这时整个CSS动画得以在compositor thread完成（而JS动画则会在main thread执行，然后触发compositor进行下一步操作）<br>\n在JS执行一些昂贵的任务时，main thread繁忙，CSS动画由于使用了compositor thread可以保持流畅。</p>\n<p>在主线程中，维护了一棵Layer树（LayerTreeHost），管理了TiledLayer，在compositor thread，维护了同样一颗LayerTreeHostImpl，管理了LayerImpl，这两棵树的内容是拷贝关系。因此可以彼此不干扰，当Javascript在main thread操作LayerTreeHost的同时，compositor thread可以用LayerTreeHostImpl做渲染。当Javascript繁忙导致主线程卡住时，合成到屏幕的过程也是流畅的。</p>\n<h3 id=\"二十三、requestanimationframe\">二十三、requestAnimationframe<a title=\"#二十三、requestanimationframe\" href=\"#二十三、requestanimationframe\"></a></h3>\n<p>requestAnimationFrame传入的回调函数在页面重绘之前调用；</p>\n<ul>\n<li>由系统来决定回调函数的执行机制。在运行时浏览器会自动优化方法的调用。</li>\n<li>requestAnimationFrame 不需要像<br>\nsetTimeout 那样传递时间间隔，而是浏览器通过系统获取并使用显示器刷<br>\n新频率</li>\n<li>提升性能，防止掉帧</li>\n<li>requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧</li>\n<li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。</li>\n</ul>\n<h3 id=\"二十四、tcp和http的关系\">二十四、tcp和http的关系<a title=\"#二十四、tcp和http的关系\" href=\"#二十四、tcp和http的关系\"></a></h3>\n<p>TCP 是传输层协议，HTTP 是应用层协议，HTTP 运行在 TCP 之上</p>\n<h3 id=\"二十五、tcp三次握手和四次回收\">二十五、TCP三次握手和四次回收<a title=\"#二十五、tcp三次握手和四次回收\" href=\"#二十五、tcp三次握手和四次回收\"></a></h3>\n<h5 id=\"三次握手\">三次握手<a title=\"#三次握手\" href=\"#三次握手\"></a></h5>\n<ul>\n<li>起初两端都处于closed关闭状态，这是客户端将标志位SYN设置为1，随机产生序列号seq=x，将数据包发送给服务端，客户端的状态变为SYNSEND状态</li>\n<li>服务端收到数据包之后，由标志位SYN等于1得知客户端需要建立连接，服务端将标志位SYN和ACk都置于1，同时将确认号ack置为x+1，再随机产生于一个序列号seq=y，将数据包返回给客户端，这是服务端进入SYNrevd状态；此时操作系统为TCP连接分配TCP缓存和变量</li>\n<li>客户端收到确认后，检查确认号ack是否为x+1，标志位ACK是否为1，如果是，则将标志位ACK置为1，确认号ack=y+1，返回给服务端，服务端收到之后查看确认号是否为y+1，标志位ACK是否为1，如果正确，则连接成功，服务端和客户端进入established状态，开始通信。<br>\n（第三次握手是为了防止已经失效的连接请求报文突然又传到了服务器，因而产生错误。）</li>\n</ul>\n<h5 id=\"四次挥手\">四次挥手<a title=\"#四次挥手\" href=\"#四次挥手\"></a></h5>\n<ul>\n<li>第一次挥手：主动关闭方发送第一个包，其中FIN标志位为1，发送顺序号seq为X。</li>\n<li>第二次挥手：被动关闭方收到FIN包后发送第二个包，其中发送顺序号seq为Z，接收顺序号ack为X+1。</li>\n<li>第三次挥手：被动关闭方再发送第三个包，其中FIN标志位为1，发送顺序号seq为Y，接收顺序号ack为X。</li>\n<li>第四次挥手：主动关闭方发送第四个包，其中发送顺序号为X，接收顺序号为Y。至此，完成四次挥手。</li>\n</ul>\n<h5 id=\"为什么要进行四次挥手\">为什么要进行四次挥手<a title=\"#为什么要进行四次挥手\" href=\"#为什么要进行四次挥手\"></a></h5>\n<p>因为双方彼此建立了连接，双方都要释放自身的连接，A向B发出一个释放连接请求，他要释放连接表明不再像B放送数据了，此时B收到A的释放连接请求，给A放松确认，A不再向B发送数据，它处于fin-wait-2状态，但是此时B还可以想A进行数据的传送。此时B向A发送一个断开连接的请求，A收到后发送确认，B收到后关闭。</p>\n<h3 id=\"二十六、闭包\">二十六、闭包<a title=\"#二十六、闭包\" href=\"#二十六、闭包\"></a></h3>\n<p>指有权访问其他函数内部变量的函数叫做闭包，简而言之就是闭包内的作用域不会不释放。简单来说闭包函数就是一个函数中的函数</p>\n<ul>\n<li>闭包的作用：<br>\n1.实现共有变量。<br>\n2.可以用作缓存。<br>\n3.可以实现函数封装，及属性私有化。<br>\n4.模块化开发，防止污染全局变量。</li>\n<li>缺点：<br>\n常驻内存 会增大内存的使用量 使用不当会造成内存泄露</li>\n</ul>\n<h3 id=\"二十七、generator函数\">二十七、generator函数<a title=\"#二十七、generator函数\" href=\"#二十七、generator函数\"></a></h3>\n<ul>\n<li>语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</li>\n<li>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态</li>\n<li>换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。</li>\n<li>next的参数会作为上一个yield的返回值</li>\n</ul>\n<h3 id=\"二十八、await-和async\">二十八、await 和async<a title=\"#二十八、await-和async\" href=\"#二十八、await-和async\"></a></h3>\n<p>简单来说他是Generator 函数的语法糖，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await</p>\n<ul>\n<li>就是将 Generator 函数和自动执行器，包装在一个函数里</li>\n<li>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</li>\n<li>await函数必须在async函数之中；</li>\n<li>如果await等待的不是一个promise对象，那么await的运算结果就是后面的值</li>\n<li>如果await等待的是一个promise对象，那么他会阻塞后面的代码等到resolve的值最为他的值</li>\n</ul>\n<h3 id=\"二十九、get和post在缓存方面的区别\">二十九、get和post在缓存方面的区别<a title=\"#二十九、get和post在缓存方面的区别\" href=\"#二十九、get和post在缓存方面的区别\"></a></h3>\n<p>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。<br>\npost不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</p>\n<h3 id=\"三十、get和post的区别\">三十、get和post的区别<a title=\"#三十、get和post的区别\" href=\"#三十、get和post的区别\"></a></h3>\n<ul>\n<li>get参数通过url传递，post放在request body中</li>\n<li>get请求在url中传递的参数是有长度限制的（2k-8k），而post是没有的</li>\n<li>get传参会具有安全问题，因为参数时暴露在url中，所以不能用来传递敏感信息</li>\n<li>get 请求使用url编码，post使用多种编码</li>\n<li>get请求会浏览器主动ache，post则不会</li>\n<li>get请求会保存在浏览器历史记录，而post中的参数不会被保留</li>\n<li>get和post本质上都是tcp连接，get产生一个tcp数据包，post会产生两个tcp数据包。</li>\n</ul>\n<h3 id=\"三十一-垃圾回收机制\">三十一 垃圾回收机制<a title=\"#三十一-垃圾回收机制\" href=\"#三十一-垃圾回收机制\"></a></h3>\n<p>一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这<br>\n几个对象也是垃圾，也要被清除。</p>\n<p>JS中最常见的垃圾回收方式是标记清除。</p>\n<p>工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p>\n<p>工作流程：</p>\n<ol>\n<li>\n<p>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。</p>\n</li>\n<li>\n<p>去掉环境中的变量以及被环境中的变量引用的变量的标记。</p>\n</li>\n<li>\n<p>再被加上标记的会被视为准备删除的变量。</p>\n</li>\n<li>\n<p>垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</p>\n</li>\n</ol>\n<p>引用计数 方式</p>\n<p>工作原理：跟踪记录每个值被引用的次数。</p>\n<p>工作流程：</p>\n<ol>\n<li>\n<p>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。</p>\n</li>\n<li>\n<p>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.</p>\n</li>\n<li>\n<p>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.</p>\n</li>\n<li>\n<p>当引用次数变成0时，说明没办法访问这个值了。</p>\n</li>\n<li>\n<p>当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。</p>\n</li>\n</ol>\n<h3 id=\"三十二.什么情况会引起内存泄漏\">三十二.什么情况会引起内存泄漏<a title=\"#三十二.什么情况会引起内存泄漏\" href=\"#三十二.什么情况会引起内存泄漏\"></a></h3>\n<p>虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。</p>\n<ol>\n<li>意外的全局变量引起的内存泄漏。</li>\n</ol>\n<p>原因：全局变量，不会被回收。</p>\n<p>解决：使用严格模式避免。</p>\n<ol start=\"2\">\n<li>闭包引起的内存泄漏</li>\n</ol>\n<p>原因：闭包可以维持函数内局部变量，使其得不到释放。</p>\n<p>解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。</p>\n<ol start=\"3\">\n<li>没有清理的DOM元素引用</li>\n</ol>\n<p>原因：虽然别的地方删除了，但是对象中还存在对dom的引用</p>\n<p>解决：手动删除。</p>\n<ol start=\"4\">\n<li>被遗忘的定时器或者回调</li>\n</ol>\n<p>原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。</p>\n<p>解决：手动删除定时器和dom。</p>\n<ol start=\"5\">\n<li>子元素存在引用引起的内存泄漏</li>\n</ol>\n<p>原因：div中的ul li  得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。</p>\n<p>解决：手动删除清空。</p>\n<h3 id=\"三十三、前端常见兼容性\">三十三、前端常见兼容性<a title=\"#三十三、前端常见兼容性\" href=\"#三十三、前端常见兼容性\"></a></h3>\n<ol>\n<li>不同浏览器的标签默认的外补丁和内补丁不同</li>\n</ol>\n<p>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。</p>\n<p>碰到频率:100%</p>\n<p>解决方案：CSS里    *{margin:0;padding:0;}</p>\n<p>备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。</p>\n<p>2.图片默认有间距<br>\n解决方案：使用float 为img 布局</p>\n<p>3.边距重叠问题；当相邻两个元素都设置了margin 边距时，margin 将取最大值，舍弃最小值；<br>\n解决方案：为了不让边重叠，可以给子元素增加一个父级元素，并设置父级元素为overflow:hidden；</p>\n<p><a href=\"http://4.td\">4.td</a> 自动换行的问题<br>\n问题：table 宽度固定，td 自动换行</p>\n<p>解决：设置 Table 为 table-layout: fixed，td 为 word-wrap: break-word</p>\n<h3 id=\"浏览器内核\">浏览器内核<a title=\"#浏览器内核\" href=\"#浏览器内核\"></a></h3>\n<ul>\n<li>trident  ------ie</li>\n<li>edgeHTMl ------edge</li>\n<li>webkit-----safari</li>\n<li>blink-----谷歌</li>\n<li>gecko------火狐</li>\n<li>presto-----opera  （03年之后采用，blink）</li>\n</ul>\n<h3 id=\"渐进增强和优雅降级\">渐进增强和优雅降级<a title=\"#渐进增强和优雅降级\" href=\"#渐进增强和优雅降级\"></a></h3>\n<p>1.什么是渐进增强</p>\n<p>在网页开发中，渐进增强认为应该专注于内容本身。一开始针对低版本的浏览器构建页面，满足最基本的功能，再针对高级浏 览器进行效果，交互，追加各种功能以达到更好用户体验,换句话说，就是以最低要求，实现最基础功能为基本，向上兼容。以css为例，以下这种写法就是渐进增强。</p>\n<p>2.什么是优雅降级</p>\n<p>在网页开发中，优雅降级指的是一开始针对一个高版本的浏览器构建页面，先完善所有的功能。然后针对各个不同的浏览器进行测试，修复，保证低级浏览器也有基本功能 就好，低级浏览器被认为“简陋却无妨 (poor, but passable)” 可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较 大的错误之外，其它的差异将被直接忽略。也就是以高要求，高版本为基准，向下兼容。同样以css为例，优雅降级的写法如下。</p>\n<h3 id=\"csrf和xss\">csrf和xss<a title=\"#csrf和xss\" href=\"#csrf和xss\"></a></h3>\n<ul>\n<li>csrf：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送恶意请求，之后再攻击者用用户的名义操作数据库，防御方式的话：使用验证码，检查https头部的referer，使用token</li>\n<li>xss：跨站脚本攻击，攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览器看到的时候进行攻击，反射型，不存储在数据库中，往往表现为将攻击代码放在url地址中， 防御方式：cooikes设置为httponly，禁止脚本访问cookie，对用户的输入进行检查，进行特殊字符的过滤。</li>\n</ul>\n<h3 id=\"video和audio的方法和事件\">Video和audio的方法和事件<a title=\"#video和audio的方法和事件\" href=\"#video和audio的方法和事件\"></a></h3>\n<ul>\n<li>方法：load() play() pause()</li>\n<li>事件：play() playing() pause() seeked() seeking() abort()当音频/视频的加载已放弃时触发</li>\n</ul>\n<h3 id=\"web应用作用域\">web应用作用域<a title=\"#web应用作用域\" href=\"#web应用作用域\"></a></h3>\n<p>Web程序对象作用域： 常用的有三个：请求作用域，会话作用域，应用上下文。 请求作用域req范围最小，需要的资源最少，作用当前请求 session会话作用于本次对话，每个对话都有JSessionID， ServletContext作用域范围大：web应用中所有都能够访问，生命周期和web容器一样长，维护所需资源多。 在满足需求内耗费的资源越小越好</p>\n<h3 id=\"background-position属性\">background-position属性<a title=\"#background-position属性\" href=\"#background-position属性\"></a></h3>\n<p>Background-position属性</p>\n<p>用处：配合background-image属性一起使用，用于设置背景图片在盒子中的位置</p>\n<p>参数：xpos ypos |x% y% |x y三种,</p>\n<p>如果只写第一个水平方向的参数，第二个垂直方向的参数会默认为：</p>\n<p>center|50%|容器高度的一半px</p>\n<p>Xpos：规定水平方向的对齐方式,值有left,right,center</p>\n<p>Ypos：规定垂直方向的对齐方式,值有top,bottom,center</p>\n<p>x%:规定图片水平方向的距离。<br>\n你会不会以为这个x%就是父级容器宽度的x%？那你就想错了哦，这里的x%指的是父级容器的宽度减去图片的宽度后的差值的x%。<br>\n举个栗子：background-position：50%，20%；<br>\n图片的宽度为     imgwidth：100px；高度为     imgheight：100px；<br>\n容器的宽度为     conwidth：200px；高度为     conheight：200px；<br>\n那么此时图片的左顶点距离容器的左顶点的水平距离就是(conwidth-imgwidth)<em>50%=50px,而不是conwidth</em>50%=100px；(很好理解的吧，不然盒子宽度200px，图片宽度100px，又距离左边100px，岂不是50%没实现水平居中而紧靠右了吗？)<br>\n由此也可以算出图片的左顶点距离容器的左顶点的垂直距离为20px<br>\ny%:对应x%</p>\n<p>x:图片距离容器水平方向距离</p>\n<p>y:图片距离容器垂直方向距离</p>\n<h3 id=\"js设计模式\">js设计模式<a title=\"#js设计模式\" href=\"#js设计模式\"></a></h3>\n<h5 id=\"1.单例模式\">1.单例模式<a title=\"#1.单例模式\" href=\"#1.单例模式\"></a></h5>\n<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var singlon = (function () &#123;</span><br><span class=\"line\">    var instance = null;</span><br><span class=\"line\">    let createdSing = function (name) &#123;</span><br><span class=\"line\">        if (instance) &#123;</span><br><span class=\"line\">            return instance</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        this.name = name</span><br><span class=\"line\">        instance = this</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return createdSing</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<h5 id=\"2.工厂模式\">2.工厂模式<a title=\"#2.工厂模式\" href=\"#2.工厂模式\"></a></h5>\n<p>工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。</p>\n<p>因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量同时解决了重复实例化的问题，缺点是无法清楚他们是哪个对象的实例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal(opts)&#123;</span><br><span class=\"line\">    var obj = new Object();</span><br><span class=\"line\">    obj.color = opts.color;</span><br><span class=\"line\">    obj.name= opts.name;</span><br><span class=\"line\">    obj.getInfo = function()&#123;</span><br><span class=\"line\">        return &#x27;名称：&#x27;+ onj.name+&#x27;， 颜色：&#x27;+ obj.color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var cat = Animal(&#123;name: &#x27;波斯猫&#x27;, color: &#x27;白色&#x27;&#125;);</span><br><span class=\"line\">cat.getInfo();</span><br></pre></td></tr></table></figure>\n<h5 id=\"3.构造函数模式\">3.构造函数模式<a title=\"#3.构造函数模式\" href=\"#3.构造函数模式\"></a></h5>\n<p>ECMAScript中的构造函数可用来创建特定类型的对象，像Array和Object这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象的属性和方法。使用构造函数的方法，既解决了重复实例化的问题，又解决了对象识别的问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal(name, color)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.color = color;</span><br><span class=\"line\">    this.getName = function()&#123;</span><br><span class=\"line\">        return this.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 实例一个对象</span><br><span class=\"line\">var cat = new Animal(&#x27;猫&#x27;, &#x27;白色&#x27;);</span><br><span class=\"line\">console.log( cat.getName() );</span><br></pre></td></tr></table></figure>\n<h5 id=\"4.订阅/发布模式\">4.订阅/发布模式<a title=\"#4.订阅/发布模式\" href=\"#4.订阅/发布模式\"></a></h5>\n<p>订阅发布模式又称为观察者模式，定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有的观察者对象。<br>\n发布者发出通知 =&gt;主题对象收到通知并推送给订阅者 =&gt; 订阅者执行相应的操作。</p>\n<ul>\n<li>初始化发布者、订阅者。</li>\n<li>订阅者需要注册到发布者，发布者发布消息时，依次向订阅者发布消息。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个发布者 publisher，功能就是负责发布消息 - publish</span><br><span class=\"line\">       var pub = &#123;</span><br><span class=\"line\">           publish: function () &#123;</span><br><span class=\"line\">               dep.notify();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       // 多个订阅者 subscribers， 在发布者发布消息之后执行函数</span><br><span class=\"line\">       var sub1 = &#123; </span><br><span class=\"line\">           update: function () &#123;</span><br><span class=\"line\">               console.log(1);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       var sub2 = &#123; </span><br><span class=\"line\">           update: function () &#123;</span><br><span class=\"line\">               console.log(2);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       var sub3 = &#123; </span><br><span class=\"line\">           update: function () &#123;</span><br><span class=\"line\">               console.log(3);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       // 一个主题对象</span><br><span class=\"line\">       function Dep() &#123;</span><br><span class=\"line\">           this.subs = [sub1, sub2, sub3];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       Dep.prototype.notify = function () &#123;</span><br><span class=\"line\">           this.subs.forEach(function (sub) &#123;</span><br><span class=\"line\">               sub.update();</span><br><span class=\"line\">           &#125;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       // 发布者发布消息， 主题对象执行notify方法，进而触发订阅者执行Update方法</span><br><span class=\"line\">       var dep = new Dep();</span><br><span class=\"line\">       pub.publish();</span><br></pre></td></tr></table></figure>\n<h5 id=\"5.mixin模式\">5.mixin模式<a title=\"#5.mixin模式\" href=\"#5.mixin模式\"></a></h5>\n<p>mixin模式就是一些提供能够被一个或者一组子类简单继承功能的类,意在重用其功能,通过javascript特有的原型链属性，将功能引用复制到原型链上，达到功能的注入。</p>\n<p>优点和缺点</p>\n<p>Mixin支持在一个系统中降解功能的重复性,增加功能的重用性.在一些应用程序也许需要在所有的对象实体共享行为的地方,我们能够通过在一个Mixin中维护这个共享的功能,来很容易的避免任何重复,而因此专注于只实现我们系统中真正彼此不同的功能。</p>\n<p>也就是说,对Mixin的副作用是值得商榷的.一些开发者感觉将功能注入到对象的原型中是一个坏点子,因为它会同时导致原型污染和一定程度上的对我们原有功能的不确定性.在大型的系统中,很可能是有这种情况的。</p>\n<h5 id=\"6.装饰者模式\">6.装饰者模式<a title=\"#6.装饰者模式\" href=\"#6.装饰者模式\"></a></h5>\n<p>什么是装饰者模式？<br>\n定义：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>\n<p>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>\n<p>何时使用：在不想增加很多子类的情况下扩展类。</p>\n<p>如何解决：将具体功能职责划分，同时继承装饰者模式。</p>\n<p>应用实例： 1、孙悟空有 72 变，当他变成&quot;庙宇&quot;后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p>\n<p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>\n<p>缺点：多层装饰比较复杂。</p>\n<p>使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>\n<p>注意事项：可代替继承。</p>\n<h3 id=\"css盒子模型\">css盒子模型<a title=\"#css盒子模型\" href=\"#css盒子模型\"></a></h3>\n<p>页面就是由一个个盒模型堆砌起来的，每个HTML元素都可以叫做盒模型，盒模型由外而内包括：边距（margin）、边框（border）、填充（padding）、内容（content）。它在页面中所占的实际宽度是margin + border + paddint + content 的宽度相加。</p>\n<ul>\n<li>标准盒模型：width只包括content     box-sizing：content-box</li>\n<li>怪异盒模型（IE模型）：IE模型的width包括content、padding和border  box-sizing：border-box</li>\n</ul>\n<h3 id=\"继承方式\">继承方式<a title=\"#继承方式\" href=\"#继承方式\"></a></h3>\n<h5 id=\"1.原型链继承\">1.原型链继承<a title=\"#1.原型链继承\" href=\"#1.原型链继承\"></a></h5>\n<p>核心： 将父类的实例作为子类的原型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Cat()&#123; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = new Animal();</span><br><span class=\"line\">Cat.prototype.name = &#x27;cat&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">//　Test Code</span><br><span class=\"line\">var cat = new Cat();</span><br><span class=\"line\">console.log(cat.name);</span><br><span class=\"line\">console.log(cat.eat(&#x27;fish&#x27;));</span><br><span class=\"line\">console.log(cat.sleep());</span><br><span class=\"line\">console.log(cat instanceof Animal); //true </span><br><span class=\"line\">console.log(cat instanceof Cat); //true</span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ul>\n<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>\n<li>父类新增原型方法/原型属性，子类都能访问到</li>\n<li>简单，易于实现</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>创建子类实例时，无法向父类构造函数传参</li>\n<li>要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中</li>\n<li>无法实现多继承</li>\n</ul>\n<h5 id=\"2.构造继承\">2.构造继承<a title=\"#2.构造继承\" href=\"#2.构造继承\"></a></h5>\n<p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Cat(name)&#123;</span><br><span class=\"line\">  Animal.call(this);</span><br><span class=\"line\">  this.name = name || &#x27;Tom&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Test Code</span><br><span class=\"line\">var cat = new Cat();</span><br><span class=\"line\">console.log(cat.name);</span><br><span class=\"line\">console.log(cat.sleep());</span><br><span class=\"line\">console.log(cat instanceof Animal); // false</span><br><span class=\"line\">console.log(cat instanceof Cat); // true</span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ul>\n<li>\n<p>解决了1中，子类实例共享父类引用属性的问题</p>\n</li>\n<li>\n<p>创建子类实例时，可以向父类传递参数</p>\n</li>\n<li>\n<p>可以实现多继承（call多个父类对象）<br>\n缺点：</p>\n</li>\n<li>\n<p>实例并不是父类的实例，只是子类的实例</p>\n</li>\n<li>\n<p>只能继承父类的实例属性和方法，不能继承原型属性/方法</p>\n</li>\n<li>\n<p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能(*)</p>\n</li>\n</ul>\n<h5 id=\"3.实例继承\">3.实例继承<a title=\"#3.实例继承\" href=\"#3.实例继承\"></a></h5>\n<p>为父类实例添加新特性，作为子类实例返回</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Cat(name)&#123;</span><br><span class=\"line\">  var instance = new Animal();</span><br><span class=\"line\">  instance.name = name || &#x27;Tom&#x27;;</span><br><span class=\"line\">  return instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Test Code</span><br><span class=\"line\">var cat = new Cat();</span><br><span class=\"line\">console.log(cat.name);</span><br><span class=\"line\">console.log(cat.sleep());</span><br><span class=\"line\">console.log(cat instanceof Animal); // true</span><br><span class=\"line\">console.log(cat instanceof Cat); // false</span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<p>不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果<br>\n缺点：</p>\n<p>实例是父类的实例，不是子类的实例<br>\n不支持多继承</p>\n<h5 id=\"4.拷贝继承\">4.拷贝继承<a title=\"#4.拷贝继承\" href=\"#4.拷贝继承\"></a></h5>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Cat(name)&#123;</span><br><span class=\"line\">  var animal = new Animal();</span><br><span class=\"line\">  for(var p in animal)&#123;</span><br><span class=\"line\">    Cat.prototype[p] = animal[p];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Cat.prototype.name = name || &#x27;Tom&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Test Code</span><br><span class=\"line\">var cat = new Cat();</span><br><span class=\"line\">console.log(cat.name);</span><br><span class=\"line\">console.log(cat.sleep());</span><br><span class=\"line\">console.log(cat instanceof Animal); // false</span><br><span class=\"line\">console.log(cat instanceof Cat); // true</span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<p>支持多继承<br>\n缺点：</p>\n<p>效率较低，内存占用高（因为要拷贝父类的属性）<br>\n无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</p>\n<h5 id=\"5.组合继承\">5.组合继承<a title=\"#5.组合继承\" href=\"#5.组合继承\"></a></h5>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Cat(name)&#123;</span><br><span class=\"line\">  Animal.call(this);</span><br><span class=\"line\">  this.name = name || &#x27;Tom&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Cat.prototype = new Animal();</span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\">// Test Code</span><br><span class=\"line\">var cat = new Cat();</span><br><span class=\"line\">console.log(cat.name);</span><br><span class=\"line\">console.log(cat.sleep());</span><br><span class=\"line\">console.log(cat instanceof Animal); // true</span><br><span class=\"line\">console.log(cat instanceof Cat); // true</span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ul>\n<li>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li>\n<li>既是子类的实例，也是父类的实例</li>\n<li>不存在引用属性共享问题</li>\n<li>可传参</li>\n<li>函数可复用<br>\n缺点：</li>\n</ul>\n<p>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</p>\n<h5 id=\"6.寄生继承\">6.寄生继承<a title=\"#6.寄生继承\" href=\"#6.寄生继承\"></a></h5>\n<p>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Cat(name)&#123;</span><br><span class=\"line\">  Animal.call(this);</span><br><span class=\"line\">  this.name = name || &#x27;Tom&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">  // 创建一个没有实例方法的类</span><br><span class=\"line\">  var Super = function()&#123;&#125;;</span><br><span class=\"line\">  Super.prototype = Animal.prototype;</span><br><span class=\"line\">  //将实例作为子类的原型</span><br><span class=\"line\">  Cat.prototype = new Super();</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">// Test Code</span><br><span class=\"line\">var cat = new Cat();</span><br><span class=\"line\">console.log(cat.name);</span><br><span class=\"line\">console.log(cat.sleep());</span><br><span class=\"line\">console.log(cat instanceof Animal); // true</span><br><span class=\"line\">console.log(cat instanceof Cat); //true</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat; // 需要修复下构造函数</span><br></pre></td></tr></table></figure>\n<p>ES5和ES6继承最大的区别就是在于：</p>\n<p>1.ES5先创建子类，在实例化父类并添加到子类this中<br>\n　　　　2.ES6先创建父类，在实例化子集中通过调用super方法访问父级后，在通过修改this实现继承</p>\n<ul>\n<li>注意：super关键字指代父类的实例，即父类的this对象。</li>\n<li>注意：在子类构造函数中，调用super后，才可使用this关键字，否则报错。</li>\n</ul>\n<h3 id=\"长连接、短连接、长轮询和websocket\">长连接、短连接、长轮询和WebSocket<a title=\"#长连接、短连接、长轮询和websocket\" href=\"#长连接、短连接、长轮询和websocket\"></a></h3>\n<ul>\n<li>\n<p>长连接：从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<br>\nConnection:keep-alive<br>\n在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>\n</li>\n<li>\n<p>短连接：在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p>\n</li>\n<li>\n<p>长轮询：（我自己的理解）客户端不断发送请求，获取服务器上的数据。在长轮询机制中，客户端像传统轮询一样从服务器请求数据。然而，如果服务器没有可以立即返回给客户端的数据，则不会立刻返回一个空结果，而是保持这个请求等待数据到来（或者恰当的超时），之后将数据作为结果返回给客户端。</p>\n</li>\n<li>\n<p>WebSocket：是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，客户端发送一次http websocket请求，服务器响应请求，双方建立持久连接，并进行双向数据传输，后面不进行HTTP连接，而是使用TCP连接。</p>\n</li>\n</ul>\n<h3 id=\"http2.0的优点\">http2.0的优点<a title=\"#http2.0的优点\" href=\"#http2.0的优点\"></a></h3>\n<ul>\n<li>提升访问速度，请求资源所需的时间更少，访问速度更快</li>\n<li>允许多路复用：允许通过单一的http2.0的连接发送多重请求-响应信息，改善了在http1.1中，在同一时间，针对同一域名的请求有一定的数量限制，超过限制会被阻塞</li>\n<li>首部压缩</li>\n<li>服务端推送</li>\n</ul>\n<h3 id=\"for..in和object.keys和reflect.ownkeys和object.getownpropertysymbols--和object.getownpropertynames\">for…in和Object.keys和reflect.ownKeys和Object.getOwnPropertySymbols  和Object.getOwnPropertyNames<a title=\"#for..in和object.keys和reflect.ownkeys和object.getownpropertysymbols--和object.getownpropertynames\" href=\"#for..in和object.keys和reflect.ownkeys和object.getownpropertysymbols--和object.getownpropertynames\"></a></h3>\n<ul>\n<li>for in  循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）</li>\n<li>Object.keys  返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）</li>\n<li>Object.getOwnPropertyNames  返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</li>\n<li>Object.getOwnPropertySymbols  返回一个数组，包含对象自身的所有Symbol属性。</li>\n<li>Reflect.ownKeys  返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举</li>\n</ul>\n<h3 id=\"双边距重叠问题\">双边距重叠问题<a title=\"#双边距重叠问题\" href=\"#双边距重叠问题\"></a></h3>\n<p>同一个BFC（块级格式化上下文）内部，相邻的两个盒子上下外边距（margin）会发生重叠。重叠之后的结果是这两个盒子相邻部分的垂直外边距取两者中较大的那个数值。</p>\n<h3 id=\"js跨域方式\">js跨域方式<a title=\"#js跨域方式\" href=\"#js跨域方式\"></a></h3>\n<h5 id=\"1.通过jsonp跨域\">1.通过jsonp跨域<a title=\"#1.通过jsonp跨域\" href=\"#1.通过jsonp跨域\"></a></h5>\n<p>JSONP包含两部分：回调函数和数据。<br>\n回调函数：当响应到来时要放在当前页面被调用的函数。<br>\n数据：就是传入回调函数中的json数据，也就是回调函数的参数了。</p>\n<h5 id=\"2.通过document.domain+iframe来跨子域(只有在主域相同的时候才能使用该方法)\">2.通过document.domain+iframe来跨子域(只有在主域相同的时候才能使用该方法)<a title=\"#2.通过document.domain+iframe来跨子域(只有在主域相同的时候才能使用该方法)\" href=\"#2.通过document.domain+iframe来跨子域(只有在主域相同的时候才能使用该方法)\"></a></h5>\n<p>浏览器同源策略限制：</p>\n<p>（1）不能通过ajax的方法去请求不同源中的文档。</p>\n<p>（2）浏览器中不同域的框架之间是不能进行js的交互操作的。</p>\n<p>所以，在不同的框架之间（父子或同辈），是能够获取到彼此的window对象的，但不能使用获取到的window对象的属性和方法(html5中的postMessage方法是一个例外)，总之，你可以当做是只能获取到一个几乎无用的window对象。</p>\n<p>document.domain的设置是有限制的：</p>\n<p>我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。<br>\n　　例如：<a href=\"http://a.b.c.com\">a.b.c.com</a> 中某个文档的document.domain <a href=\"http://xn--a-206a34nowrjf3c.b.c.com\">可以设成a.b.c.com</a>、<a href=\"http://b.c.com\">b.c.com</a> 、c.com中的任意一个</p>\n<h5 id=\"3.使用window.name+iframe来进行跨域\">3.使用window.name+iframe来进行跨域<a title=\"#3.使用window.name+iframe来进行跨域\" href=\"#3.使用window.name+iframe来进行跨域\"></a></h5>\n<p>window的name属性特征：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB），即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面window.name都有读写的权限。</p>\n<h5 id=\"4.使用window.postmessage方法来跨域(不常用)\">4.使用window.postMessage方法来跨域(不常用)<a title=\"#4.使用window.postmessage方法来跨域(不常用)\" href=\"#4.使用window.postmessage方法来跨域(不常用)\"></a></h5>\n<p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源(可实现跨域)，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p>\n<ul>\n<li>message：为要发送的消息，类型只能为字符串；</li>\n<li>targetOrigin：用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 “*”。</li>\n</ul>\n<p><a href=\"http://xn--www-th2el20d.test.com/a.html%E9%A1%B5%E9%9D%A2%E4%BB%A3%E7%A0%81%EF%BC%9A\">创建www.test.com/a.html页面代码：</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">function onLoad()&#123;</span><br><span class=\"line\">    var iframe = document.getElementById(&quot;iframe&quot;);</span><br><span class=\"line\">    var win = iframe.contentWindow;</span><br><span class=\"line\">    win.postMessage(&#x27;哈哈，我是来自页面a.html的信息哟！&#x27;,&#x27;*&#x27;);//向不同域的www.script.com/b.html发送消息</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;iframe id=&quot;iframe&quot; src=&quot;www.script.com/b.html&quot; onload=&quot;onLoad()&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://xn--www-th2el20d.script.com/b.html%E9%A1%B5%E9%9D%A2%E4%BB%A3%E7%A0%81%EF%BC%9A\">创建www.script.com/b.html页面代码：</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;script&gt;</span><br><span class=\"line\">window.onmessage = function(e)&#123;//注册message时间来接收消息</span><br><span class=\"line\">   e = e || event;            //获取时间对象</span><br><span class=\"line\">   alert(e.data);             //通过data属性来得到传送的消息</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"5.使用跨域资源共享（cors）来跨域\">5.使用跨域资源共享（CORS）来跨域<a title=\"#5.使用跨域资源共享（cors）来跨域\" href=\"#5.使用跨域资源共享（cors）来跨域\"></a></h5>\n<p>CORS：一种跨域访问的机制，可以让AJAX实现跨域访问；CORS允许一个域上的网络应用向另一个域提交跨域AJAX请求。<br>\n服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求．<br>\n就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>\n<h5 id=\"6.使用web-sockets来跨域\">6.使用Web sockets来跨域<a title=\"#6.使用web-sockets来跨域\" href=\"#6.使用web-sockets来跨域\"></a></h5>\n<p>web sockets： 是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)</p>\n<p>web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var socket = new WebSockt(&#x27;ws://www.test.com&#x27;);</span><br><span class=\"line\">//http-&gt;ws; https-&gt;wss</span><br><span class=\"line\">socket.send(&#x27;hello WebSockt&#x27;);</span><br><span class=\"line\">socket.onmessage = function(event)&#123;</span><br><span class=\"line\">    var data = event.data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","prev":{"title":"vue面试题","link":"2021/09/05/vue面试题"},"next":{"title":"Hello World","link":"2021/09/04/hello-world"},"plink":"http://example.com/2021/09/05/前端面试题（上）/","toc":[{"id":"typeof和instanceof","title":"typeof和instanceof","index":"1"},{"id":"spa和ssr的区别","title":"spa和ssr的区别","index":"2"},{"id":"圣杯布局和双飞翼布局的作用和区别","title":"圣杯布局和双飞翼布局的作用和区别","index":"3"},{"id":"event.target和event.currenttarget","title":"event.target和event.currentTarget","index":"4"},{"id":"xhtml和html的区别","title":"XHTML和html的区别","index":"5"},{"id":"事件模型","title":"事件模型","index":"6"},{"id":"git的基本使用","title":"git的基本使用","index":"7"},{"id":"webpack模块热替换","title":"webpack模块热替换","index":"8"},{"id":"一、event-loop-事件循环：","title":"一、event loop 事件循环：","index":"9"},{"id":"二、浏览器缓存：强缓存和协商缓存","title":"二、浏览器缓存：强缓存和协商缓存","index":"10"},{"id":"重绘和重排","title":"重绘和重排","index":"11"},{"id":"三、节流和防抖","title":"三、节流和防抖","index":"12"},{"id":"三、web-worker","title":"三、web worker","index":"13"},{"id":"四、原型链","title":"四、原型链","index":"14"},{"id":"原型链污染","title":"原型链污染","index":"15"},{"id":"五、new一个构造函数的过程","title":"五、new一个构造函数的过程","index":"16"},{"id":"六、promise原理","title":"六、promise原理","index":"17"},{"id":"七、content-type","title":"七、Content-type","index":"18"},{"id":"八、mouseover和mouseleave的区别","title":"八、mouseover和mouseleave的区别","index":"19"},{"id":"九、canvas和svg","title":"九、canvas和svg","index":"20"},{"id":"十、clientheight、offsetheight、scrollheight","title":"十、clientHeight、offsetHeight、scrollHeight","index":"21"},{"id":"十一、线程和进程","title":"十一、线程和进程","index":"22"},{"id":"十二、普通函数和箭头函数的区别","title":"十二、普通函数和箭头函数的区别","index":"23"},{"id":"this","title":"this","index":"24"},{"id":"十三、var-let-const","title":"十三、var let const","index":"25"},{"id":"十四、null和undefined的区别","title":"十四、null和undefined的区别","index":"26"},{"id":"十五、json.stingify深拷贝的缺点","title":"十五、JSON.stingify深拷贝的缺点","index":"27"},{"id":"十六、require和import","title":"十六、require和import","index":"28"},{"id":"十七、常见选择器","title":"十七、常见选择器","index":"29"},{"id":"十八、clientx/clienty、screenx/screeny、pagex/pagey、offsetx/offsety","title":"十八、clientX&#x2F;clientY、screenX&#x2F;screenY、pageX&#x2F;pageY、offsetX&#x2F;offsetY","index":"30"},{"id":"十九、常见布局方式","title":"十九、常见布局方式","index":"31"},{"id":"二十、resultful的特点","title":"二十、resultFul的特点","index":"32","children":[{"id":"rest的含义","title":"rest的含义","index":"32.1"},{"id":"restful的原则","title":"restful的原则","index":"32.2"}]},{"id":"二十一、cdn网站加速","title":"二十一、CDN网站加速","index":"33"},{"id":"二十二、js动画和css动画的区别","title":"二十二、js动画和css动画的区别","index":"34"},{"id":"二十三、requestanimationframe","title":"二十三、requestAnimationframe","index":"35"},{"id":"二十四、tcp和http的关系","title":"二十四、tcp和http的关系","index":"36"},{"id":"二十五、tcp三次握手和四次回收","title":"二十五、TCP三次握手和四次回收","index":"37"},{"id":"二十六、闭包","title":"二十六、闭包","index":"38"},{"id":"二十七、generator函数","title":"二十七、generator函数","index":"39"},{"id":"二十八、await-和async","title":"二十八、await 和async","index":"40"},{"id":"二十九、get和post在缓存方面的区别","title":"二十九、get和post在缓存方面的区别","index":"41"},{"id":"三十、get和post的区别","title":"三十、get和post的区别","index":"42"},{"id":"三十一-垃圾回收机制","title":"三十一 垃圾回收机制","index":"43"},{"id":"三十二.什么情况会引起内存泄漏","title":"三十二.什么情况会引起内存泄漏","index":"44"},{"id":"三十三、前端常见兼容性","title":"三十三、前端常见兼容性","index":"45"},{"id":"浏览器内核","title":"浏览器内核","index":"46"},{"id":"渐进增强和优雅降级","title":"渐进增强和优雅降级","index":"47"},{"id":"csrf和xss","title":"csrf和xss","index":"48"},{"id":"video和audio的方法和事件","title":"Video和audio的方法和事件","index":"49"},{"id":"web应用作用域","title":"web应用作用域","index":"50"},{"id":"background-position属性","title":"background-position属性","index":"51"},{"id":"js设计模式","title":"js设计模式","index":"52"},{"id":"css盒子模型","title":"css盒子模型","index":"53"},{"id":"继承方式","title":"继承方式","index":"54"},{"id":"长连接、短连接、长轮询和websocket","title":"长连接、短连接、长轮询和WebSocket","index":"55"},{"id":"http2.0的优点","title":"http2.0的优点","index":"56"},{"id":"for..in和object.keys和reflect.ownkeys和object.getownpropertysymbols--和object.getownpropertynames","title":"for…in和Object.keys和reflect.ownKeys和Object.getOwnPropertySymbols  和Object.getOwnPropertyNames","index":"57"},{"id":"双边距重叠问题","title":"双边距重叠问题","index":"58"},{"id":"js跨域方式","title":"js跨域方式","index":"59"}],"reward":true,"copyright":{"license":"自由转载-非商用-禁止演绎-保持署名（<a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\">CC BY-NC-ND 4.0</a>）","link":"<a href=\"http://example.com/2021/09/05/前端面试题（上）/\" title=\"前端面试题（上）\">http://example.com/2021/09/05/前端面试题（上）/</a>","published":"2021年9月5日","updated":"2021年9月5日"},"reading_time":"16389 words in 109 min"}