{"title":"vue面试题","date":"2021-09-05T09:04:18.000Z","date_formatted":{"ll":"2021年9月5日","L":"2021/09/05","MM-DD":"09-05"},"thumbnail":"https://i.loli.net/2021/09/05/zO3UMLb584oiVwN.jpg","link":"2021/09/05/vue面试题","comments":true,"tags":["CSS","HTML","JS","VUE"],"categories":["面经"],"updated":"2021-09-05T09:15:18.942Z","content":"<h3 id=\"vue和react的区别\">vue和react的区别<a title=\"#vue和react的区别\" href=\"#vue和react的区别\"></a></h3>\n<ul>\n<li>模板 vs JSX<br>\n监听数据变化的实现原理不同</li>\n</ul>\n<p>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</p>\n<p>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染</p>\n<p>Vue本质是MVVM框架，由MVC发展而来；</p>\n<p>React是前端组件化框架，由后端组件化发展而来。</p>\n<h3 id=\"webpack打包原理\">webpack打包原理<a title=\"#webpack打包原理\" href=\"#webpack打包原理\"></a></h3>\n<p>webpack 是一个模块打包机，将根据文件间的依赖关系对其进行静态分析，然后将这些模块按指定规则生成静态资源</p>\n<p>当 webpack 处理程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle</p>\n<h3 id=\"vue初始化\">vue初始化<a title=\"#vue初始化\" href=\"#vue初始化\"></a></h3>\n<p>Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher</p>\n<h3 id=\"vue组件封装过程\">Vue组件封装过程<a title=\"#vue组件封装过程\" href=\"#vue组件封装过程\"></a></h3>\n<p>● 首先，使用Vue.extend()创建一个组件</p>\n<p>● 然后，使用Vue.component()方法注册组件</p>\n<p>● 接着，如果子组件需要数据，可以在props中接受定义</p>\n<p>● 最后，子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法</p>\n<h3 id=\"vue的生命周期\">vue的生命周期<a title=\"#vue的生命周期\" href=\"#vue的生命周期\"></a></h3>\n<p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。<br>\n每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。</p>\n<p>实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</p>\n<p>挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</p>\n<p>接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</p>\n<p>接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情…</p>\n<p>当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿</p>\n<p>当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom</p>\n<p>当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等</p>\n<p>组件的数据绑定、监听…去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以</p>\n<h3 id=\"一、v-if和v-show\">一、v-if和v-show<a title=\"#一、v-if和v-show\" href=\"#一、v-if和v-show\"></a></h3>\n<ul>\n<li>v-show和v-if都是动态的控制元素的隐藏和显示</li>\n<li>v-show是同过css中display设置为none进行隐藏和显示，v-if则是将dom元素整个的删除和添加，同时v-if是惰性的，也就是说如果初始条件是fasle，那么页面是不会编译这个元素节点的。</li>\n<li>v-if具有较高的切换消耗，而v-show具有较高的初始渲染消耗</li>\n<li>所以v-show适合频繁的切换，而v-if适合运营条件不大可能改变的情况。</li>\n</ul>\n<h3 id=\"二、什么是mvvm\">二、什么是MVVM<a title=\"#二、什么是mvvm\" href=\"#二、什么是mvvm\"></a></h3>\n<h5 id=\"mvvm是model-view-viewmodel的缩写，mvvm是一种设计思想，model是代表数据模型：可在model中定义数据修改和操作的业务逻辑，view负责将数据模型转化ui展示，而viewmodel是view和model之间的桥梁，\">mvvm是Model-view-viewModel的缩写，mvvm是一种设计思想，Model是代表数据模型：可在model中定义数据修改和操作的业务逻辑，view负责将数据模型转化ui展示，而viewmodel是view和Model之间的桥梁，<a title=\"#mvvm是model-view-viewmodel的缩写，mvvm是一种设计思想，model是代表数据模型：可在model中定义数据修改和操作的业务逻辑，view负责将数据模型转化ui展示，而viewmodel是view和model之间的桥梁，\" href=\"#mvvm是model-view-viewmodel的缩写，mvvm是一种设计思想，model是代表数据模型：可在model中定义数据修改和操作的业务逻辑，view负责将数据模型转化ui展示，而viewmodel是view和model之间的桥梁，\"></a></h5>\n<h5 id=\"在mvvm的架构下，view和model之间没有直接的联系，而是通过viewmodel进行交互，而model和viewmodel之间的交互是双向，viewmodel通过双向数据绑定把view层和model层连接起来，因此开发者只需关注业务逻辑，不需要手动操作dom,-不需要关注数据状态的同步问题，复杂的数据状态维护完全由-mvvm-来统一管理。\">在mvvm的架构下，view和model之间没有直接的联系，而是通过viewmodel进行交互，而model和viewModel之间的交互是双向，viewMOdel通过双向数据绑定把View层和Model层连接起来，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。<a title=\"#在mvvm的架构下，view和model之间没有直接的联系，而是通过viewmodel进行交互，而model和viewmodel之间的交互是双向，viewmodel通过双向数据绑定把view层和model层连接起来，因此开发者只需关注业务逻辑，不需要手动操作dom,-不需要关注数据状态的同步问题，复杂的数据状态维护完全由-mvvm-来统一管理。\" href=\"#在mvvm的架构下，view和model之间没有直接的联系，而是通过viewmodel进行交互，而model和viewmodel之间的交互是双向，viewmodel通过双向数据绑定把view层和model层连接起来，因此开发者只需关注业务逻辑，不需要手动操作dom,-不需要关注数据状态的同步问题，复杂的数据状态维护完全由-mvvm-来统一管理。\"></a></h5>\n<h5 id=\"优点：mvvm主要解决了mvc中大量的dom-操作使页面渲染性能降低，加载速度变慢，影响用户体验。\">优点：mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。<a title=\"#优点：mvvm主要解决了mvc中大量的dom-操作使页面渲染性能降低，加载速度变慢，影响用户体验。\" href=\"#优点：mvvm主要解决了mvc中大量的dom-操作使页面渲染性能降低，加载速度变慢，影响用户体验。\"></a></h5>\n<h3 id=\"三、双向数据绑定原理\">三、双向数据绑定原理<a title=\"#三、双向数据绑定原理\" href=\"#三、双向数据绑定原理\"></a></h3>\n<h5 id=\"vue实例通过数据劫持和发布订阅者模式的方式来实现双向数据绑定，主要通过object.defineprototype来动态的劫持getters和setter来实现双向数据绑定，vue.js是无法通过defineprototype的getter和setter监听数组的变化，虽然可以监听索引值的改变监听数组，但准确的来说无法通过length的变化监听数组，vue.js将data中数组原型链方法进行了重写，指向了自己定义的数组原型方法，这样当调用数组-api-时，可以通知依赖更新.如果数组中包含着引用类型。会对数组中的引用类型再次进行监控\">vue实例通过数据劫持和发布订阅者模式的方式来实现双向数据绑定，主要通过object.defineprototype来动态的劫持getters和setter来实现双向数据绑定，vue.js是无法通过defineprototype的getter和setter监听数组的变化，虽然可以监听索引值的改变监听数组，但准确的来说无法通过length的变化监听数组，vue.js将data中数组原型链方法进行了重写，指向了自己定义的数组原型方法，这样当调用数组 api 时，可以通知依赖更新.如果数组中包含着引用类型。会对数组中的引用类型再次进行监控<a title=\"#vue实例通过数据劫持和发布订阅者模式的方式来实现双向数据绑定，主要通过object.defineprototype来动态的劫持getters和setter来实现双向数据绑定，vue.js是无法通过defineprototype的getter和setter监听数组的变化，虽然可以监听索引值的改变监听数组，但准确的来说无法通过length的变化监听数组，vue.js将data中数组原型链方法进行了重写，指向了自己定义的数组原型方法，这样当调用数组-api-时，可以通知依赖更新.如果数组中包含着引用类型。会对数组中的引用类型再次进行监控\" href=\"#vue实例通过数据劫持和发布订阅者模式的方式来实现双向数据绑定，主要通过object.defineprototype来动态的劫持getters和setter来实现双向数据绑定，vue.js是无法通过defineprototype的getter和setter监听数组的变化，虽然可以监听索引值的改变监听数组，但准确的来说无法通过length的变化监听数组，vue.js将data中数组原型链方法进行了重写，指向了自己定义的数组原型方法，这样当调用数组-api-时，可以通知依赖更新.如果数组中包含着引用类型。会对数组中的引用类型再次进行监控\"></a></h5>\n<ul>\n<li>初始化发布者、订阅者。</li>\n<li>订阅者需要注册到发布者，发布者发布消息时，依次向订阅者发布消息。</li>\n<li>实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</li>\n<li>实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</li>\n<li>实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器</li>\n</ul>\n<h3 id=\"四、vue的优点\">四、vue的优点<a title=\"#四、vue的优点\" href=\"#四、vue的优点\"></a></h3>\n<ul>\n<li>低耦合， 视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>\n<li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li>\n<li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li>\n<li>轻量级框架。只关注视图层,是一个构建数据的视图集合,大小只有几十kb</li>\n<li>运行速度更快</li>\n<li>虚拟DOM</li>\n</ul>\n<h3 id=\"五、为什么vue中data必须是一个函数\">五、为什么vue中data必须是一个函数<a title=\"#五、为什么vue中data必须是一个函数\" href=\"#五、为什么vue中data必须是一个函数\"></a></h3>\n<p>因为对象是引用类型，当重组组件时，由于数据对象都指向同一个data 对象，所以修改一个组件的data 对象时，所有的都会修改，如果返回的是一个对象函数，那么就是一个新的对象，因为引用地址不同，所以修改一处时，其他组件的data不会改变。</p>\n<h3 id=\"六、vue路由守卫\">六、vue路由守卫<a title=\"#六、vue路由守卫\" href=\"#六、vue路由守卫\"></a></h3>\n<p>一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。<br>\n第二种：组件内的钩子；beforeRouteEnter、beforeRouteUpdate(2.2新增)、beforeRouteLeave<br>\n第三种：单独路由独享组件（beforeEnter）</p>\n<h3 id=\"七、组件传值方法\">七、组件传值方法<a title=\"#七、组件传值方法\" href=\"#七、组件传值方法\"></a></h3>\n<ul>\n<li>props/$emit,父传子使用props，而emit是子传父</li>\n<li>$emit/$on,这种方法是通过一个空的vue实例作为中央事件总线，用它来出发事件和监听事件，巧妙实现的数据的传递，</li>\n<li>vuex(状态管理器)，vuex实现了一个单向数据流，在全局拥有一个state存放数据，当组件需要更改state在中的数据时，需要通过mutation进行，mutation提供了订阅者模式供外部插件调用获取state数据。而当所有异步操作或批量的同步操作走action时，任然需要通过mutation来修改state数据，最后会更具state的数据变化，渲染到视图上。</li>\n<li>$attrs/$listeners,适用于多级嵌套传参；$attrs包含了父作用域中不被prop所识别的特定属性，$listeners:包含了父作用域中的v-on事件监听器</li>\n</ul>\n<h3 id=\"八、computed和watch的区别\">八、computed和watch的区别<a title=\"#八、computed和watch的区别\" href=\"#八、computed和watch的区别\"></a></h3>\n<ul>\n<li>computed用声明式的方式描述一个值依赖其他的值，当模板上的属性绑定到计算属性中市，vue会在其他依赖值发生改变导致该计算属性发生改变的时候更新DOM</li>\n</ul>\n<p>计算属性computed : （多个属性影响一个属性）</p>\n<ol>\n<li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li>\n<li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化<br>\n3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li>\n<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed<br>\n5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li>\n</ol>\n<ul>\n<li>watch监听的是你定义的变量，当你定义的变量的值发生变化时，调用对应的方法（一个数据影响多个数据）<br>\n侦听属性watch：</li>\n</ul>\n<ol>\n<li>不支持缓存，数据变，直接会触发相应的操作；<br>\n2.watch支持异步；<br>\n3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li>\n<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>\n<li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，<br>\n　　immediate：组件加载立即触发回调函数执行，<br>\n　　deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</li>\n</ol>\n<h3 id=\"九、keep-alive\">九、keep-alive<a title=\"#九、keep-alive\" href=\"#九、keep-alive\"></a></h3>\n<p>keep-alive是Vue的内置组件，包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。</p>\n<h3 id=\"十、key\">十、key<a title=\"#十、key\" href=\"#十、key\"></a></h3>\n<p>当有相同标签名的元素切换时，需要通过key特效来设置唯一的值来标记这个标签，防止vue为了效率替换掉同名标签内的内容</p>\n<h3 id=\"避免同时使用v-if和v-for\">避免同时使用v-if和v-for<a title=\"#避免同时使用v-if和v-for\" href=\"#避免同时使用v-if和v-for\"></a></h3>\n<p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。</p>\n<h3 id=\"ctive-class是哪个组件的属性？嵌套路由怎么定义？\">ctive-class是哪个组件的属性？嵌套路由怎么定义？<a title=\"#ctive-class是哪个组件的属性？嵌套路由怎么定义？\" href=\"#ctive-class是哪个组件的属性？嵌套路由怎么定义？\"></a></h3>\n<p>vue-router模块的router-link组件。<br>\n嵌套路由顾名思义就是路由的多层嵌套。 一级路由里面使用children数组配置子路由，就是嵌套路由。</p>\n<h3 id=\"十一、.$nexttick是什么\">十一、.$nextTick是什么<a title=\"#十一、.$nexttick是什么\" href=\"#十一、.$nexttick是什么\"></a></h3>\n<p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。<br>\n$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM</p>\n<h3 id=\"十二、directive自定义指令\">十二、directive自定义指令<a title=\"#十二、directive自定义指令\" href=\"#十二、directive自定义指令\"></a></h3>\n<p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>\n<p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>\n<p>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>\n<p>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p>\n<p>我们会在稍后讨论渲染函数时介绍更多 VNodes 的细节。</p>\n<p>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p>\n<p>unbind：只调用一次，指令与元素解绑时调用。</p>\n<p>接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。</p>\n<h3 id=\"十三、hash和history\">十三、hash和history<a title=\"#十三、hash和history\" href=\"#十三、hash和history\"></a></h3>\n<ul>\n<li>hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取； 特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 hash 模式下:仅 hash 符号之前的内容会被包含在请求中，如 <a href=\"http://www.xxx.com\">http://www.xxx.com</a>，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。</li>\n<li>history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。</li>\n</ul>\n<h3 id=\"十四、$route和$router的区别\">十四、$route和$router的区别<a title=\"#十四、$route和$router的区别\" href=\"#十四、$route和$router的区别\"></a></h3>\n<ul>\n<li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li>\n<li>$router是’路由实例’对象包括了路由的跳转方法，钩子函数等。</li>\n</ul>\n<h3 id=\"十五、vue响应式原理\">十五、vue响应式原理<a title=\"#十五、vue响应式原理\" href=\"#十五、vue响应式原理\"></a></h3>\n<p>有一个数据a.b,在vue对象实例化过程中，会给a,b通过ES5的defineProperty()方法，添加getter和setter方法，同时vue.js会对模板做编译，解析生成一个指令对象，比如v-text指令，每个指令对象都会关联一个watcher，当对指令对象求值时，就会触发getter，并将依赖收集到watcher中；当再次改变a.b值时，就会触发setter方法，会通知到对应关联的watcher,watcher则再次对a.b求值，计算对比新旧值，当值改变时，watcher会通知到指令，调用指令的update方法，由于指令是对dom的封装，所以会调用原生dom的方法，去更新视图。</p>\n<h3 id=\"十六、babel工作原理\">十六、babel工作原理<a title=\"#十六、babel工作原理\" href=\"#十六、babel工作原理\"></a></h3>\n<p>babel是一个转译器，因为它只是把同种语言的高版本规则翻译成低版本规则<br>\nbabel的转译过程也分为三个阶段：parsing、transforming、generating<br>\nES6代码输入 ==》 babylon进行解析 ==》 得到AST<br>\n==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树<br>\n==》 用babel-generator通过AST树生成ES5代码</p>\n<h3 id=\"十七、render函数\">十七、render函数<a title=\"#十七、render函数\" href=\"#十七、render函数\"></a></h3>\n<p>简单的说，在vue中我们使用模板HTML语法组建页面的，使用render函数我们可以用js语言来构建DOM</p>\n<p>因为vue是虚拟DOM，所以在拿到template模板时也要转译成VNode的函数，而用render函数构建DOM，vue就免去了转译的过程。</p>\n<p>当使用render函数描述虚拟DOM时，vue提供一个函数，这个函数是就构建虚拟DOM所需要的工具。</p>\n<h3 id=\"十八、vue3.0的新特性\">十八、vue3.0的新特性<a title=\"#十八、vue3.0的新特性\" href=\"#十八、vue3.0的新特性\"></a></h3>\n<h5 id=\"object.defineproperty--&gt;-proxy\">Object.defineProperty -&gt; Proxy<a title=\"#object.defineproperty--&gt;-proxy\" href=\"#object.defineproperty--&gt;-proxy\"></a></h5>\n<p>Object.defineProperty是一个相对比较昂贵的操作，因为它直接操作对象的属性，颗粒度比较小。将它替换为es6的Proxy，在目标对象之上架了一层拦截，代理的是对象而不是对象的属性。这样可以将原本对对象属性的操作变为对整个对象的操作，颗粒度变大。</p>\n<h5 id=\"vue3.0中对diff算法进行了优化：\">vue3.0中对diff算法进行了优化：<a title=\"#vue3.0中对diff算法进行了优化：\" href=\"#vue3.0中对diff算法进行了优化：\"></a></h5>\n<ul>\n<li>vue2中的diff算法是将虚拟dom进行全量比较</li>\n<li>vue3中diff算法中新增了静态标记，也就是说在于上次虚拟节点进行对比的时候，只对比带有patch flag的节点，并且可以通过flag的信息得知当前节点要对比的具体内容</li>\n</ul>\n<h3 id=\"十九、vue渲染原理\">十九、vue渲染原理<a title=\"#十九、vue渲染原理\" href=\"#十九、vue渲染原理\"></a></h3>\n<p>Vue的编译器在编译（template）模板之后，先将模板解析成AST(Abstract Syntax Tree，抽象语法树)，然后再使用AST生成渲染函数，而函数被调用的时候，就会返回一个虚拟DOM树，当我们有了这个虚拟dom树之后，再交给一个patch函数，负责把这些虚拟DOM真正渲染到真实的DOm之上，在这个过程中，Vue有自身的响应式系统来侦测在渲染过程中所依赖到 的数据来源之后，可以通过双向数据绑定，来感知数据的改变，进行重新渲染。</p>\n<h3 id=\"ast-抽象语法树\">AST 抽象语法树<a title=\"#ast-抽象语法树\" href=\"#ast-抽象语法树\"></a></h3>\n<p>AST不依赖于具体的文法，不依赖于语言的细节，我们将源代码转化为AST后，可以对AST做很多的操作</p>\n<p>抽象语法树（Abstract Syntax Tree）也称为AST语法树，指的是源代码语法所对应的树状结构。也就是说，对于一种具体编程语言下的源代码，通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上。</p>\n","next":{"title":"前端面试题（上）","link":"2021/09/05/前端面试题（上）"},"plink":"http://example.com/2021/09/05/vue面试题/","toc":[{"id":"vue和react的区别","title":"vue和react的区别","index":"1"},{"id":"webpack打包原理","title":"webpack打包原理","index":"2"},{"id":"vue初始化","title":"vue初始化","index":"3"},{"id":"vue组件封装过程","title":"Vue组件封装过程","index":"4"},{"id":"vue的生命周期","title":"vue的生命周期","index":"5"},{"id":"一、v-if和v-show","title":"一、v-if和v-show","index":"6"},{"id":"二、什么是mvvm","title":"二、什么是MVVM","index":"7"},{"id":"三、双向数据绑定原理","title":"三、双向数据绑定原理","index":"8"},{"id":"四、vue的优点","title":"四、vue的优点","index":"9"},{"id":"五、为什么vue中data必须是一个函数","title":"五、为什么vue中data必须是一个函数","index":"10"},{"id":"六、vue路由守卫","title":"六、vue路由守卫","index":"11"},{"id":"七、组件传值方法","title":"七、组件传值方法","index":"12"},{"id":"八、computed和watch的区别","title":"八、computed和watch的区别","index":"13"},{"id":"九、keep-alive","title":"九、keep-alive","index":"14"},{"id":"十、key","title":"十、key","index":"15"},{"id":"避免同时使用v-if和v-for","title":"避免同时使用v-if和v-for","index":"16"},{"id":"ctive-class是哪个组件的属性？嵌套路由怎么定义？","title":"ctive-class是哪个组件的属性？嵌套路由怎么定义？","index":"17"},{"id":"十一、.$nexttick是什么","title":"十一、.$nextTick是什么","index":"18"},{"id":"十二、directive自定义指令","title":"十二、directive自定义指令","index":"19"},{"id":"十三、hash和history","title":"十三、hash和history","index":"20"},{"id":"十四、$route和$router的区别","title":"十四、$route和$router的区别","index":"21"},{"id":"十五、vue响应式原理","title":"十五、vue响应式原理","index":"22"},{"id":"十六、babel工作原理","title":"十六、babel工作原理","index":"23"},{"id":"十七、render函数","title":"十七、render函数","index":"24"},{"id":"十八、vue3.0的新特性","title":"十八、vue3.0的新特性","index":"25"},{"id":"十九、vue渲染原理","title":"十九、vue渲染原理","index":"26"},{"id":"ast-抽象语法树","title":"AST 抽象语法树","index":"27"}],"reward":true,"copyright":{"license":"自由转载-非商用-禁止演绎-保持署名（<a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\">CC BY-NC-ND 4.0</a>）","link":"<a href=\"http://example.com/2021/09/05/vue面试题/\" title=\"vue面试题\">http://example.com/2021/09/05/vue面试题/</a>","published":"2021年9月5日","updated":"2021年9月5日"},"reading_time":"4681 words in 31 min"}