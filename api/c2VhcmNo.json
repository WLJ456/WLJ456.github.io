[{"title":"vue面试题","date":"2021-09-05T09:04:18.000Z","date_formatted":{"ll":"2021年9月5日","L":"2021/09/05","MM-DD":"09-05"},"updated":"2021-09-05T09:15:18.942Z","content":"vue和react的区别\n\n模板 vs JSX\n监听数据变化的实现原理不同\n\nVue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能\nReact 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染\nVue本质是MVVM框架，由MVC发展而来；\nReact是前端组件化框架，由后端组件化发展而来。\nwebpack打包原理\nwebpack 是一个模块打包机，将根据文件间的依赖关系对其进行静态分析，然后将这些模块按指定规则生成静态资源\n当 webpack 处理程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle\nvue初始化\nVue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher\nVue组件封装过程\n● 首先，使用Vue.extend()创建一个组件\n● 然后，使用Vue.component()方法注册组件\n● 接着，如果子组件需要数据，可以在props中接受定义\n● 最后，子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法\nvue的生命周期\nVue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。\n每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。\n实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作\n挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取\n接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取\n接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情…\n当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿\n当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom\n当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等\n组件的数据绑定、监听…去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以\n一、v-if和v-show\n\nv-show和v-if都是动态的控制元素的隐藏和显示\nv-show是同过css中display设置为none进行隐藏和显示，v-if则是将dom元素整个的删除和添加，同时v-if是惰性的，也就是说如果初始条件是fasle，那么页面是不会编译这个元素节点的。\nv-if具有较高的切换消耗，而v-show具有较高的初始渲染消耗\n所以v-show适合频繁的切换，而v-if适合运营条件不大可能改变的情况。\n\n二、什么是MVVM\nmvvm是Model-view-viewModel的缩写，mvvm是一种设计思想，Model是代表数据模型：可在model中定义数据修改和操作的业务逻辑，view负责将数据模型转化ui展示，而viewmodel是view和Model之间的桥梁，\n在mvvm的架构下，view和model之间没有直接的联系，而是通过viewmodel进行交互，而model和viewModel之间的交互是双向，viewMOdel通过双向数据绑定把View层和Model层连接起来，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\n优点：mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。\n三、双向数据绑定原理\nvue实例通过数据劫持和发布订阅者模式的方式来实现双向数据绑定，主要通过object.defineprototype来动态的劫持getters和setter来实现双向数据绑定，vue.js是无法通过defineprototype的getter和setter监听数组的变化，虽然可以监听索引值的改变监听数组，但准确的来说无法通过length的变化监听数组，vue.js将data中数组原型链方法进行了重写，指向了自己定义的数组原型方法，这样当调用数组 api 时，可以通知依赖更新.如果数组中包含着引用类型。会对数组中的引用类型再次进行监控\n\n初始化发布者、订阅者。\n订阅者需要注册到发布者，发布者发布消息时，依次向订阅者发布消息。\n实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。\n实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。\n实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器\n\n四、vue的优点\n\n低耦合， 视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。\n可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。\n独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。\n轻量级框架。只关注视图层,是一个构建数据的视图集合,大小只有几十kb\n运行速度更快\n虚拟DOM\n\n五、为什么vue中data必须是一个函数\n因为对象是引用类型，当重组组件时，由于数据对象都指向同一个data 对象，所以修改一个组件的data 对象时，所有的都会修改，如果返回的是一个对象函数，那么就是一个新的对象，因为引用地址不同，所以修改一处时，其他组件的data不会改变。\n六、vue路由守卫\n一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。\n第二种：组件内的钩子；beforeRouteEnter、beforeRouteUpdate(2.2新增)、beforeRouteLeave\n第三种：单独路由独享组件（beforeEnter）\n七、组件传值方法\n\nprops/$emit,父传子使用props，而emit是子传父\n$emit/$on,这种方法是通过一个空的vue实例作为中央事件总线，用它来出发事件和监听事件，巧妙实现的数据的传递，\nvuex(状态管理器)，vuex实现了一个单向数据流，在全局拥有一个state存放数据，当组件需要更改state在中的数据时，需要通过mutation进行，mutation提供了订阅者模式供外部插件调用获取state数据。而当所有异步操作或批量的同步操作走action时，任然需要通过mutation来修改state数据，最后会更具state的数据变化，渲染到视图上。\n$attrs/$listeners,适用于多级嵌套传参；$attrs包含了父作用域中不被prop所识别的特定属性，$listeners:包含了父作用域中的v-on事件监听器\n\n八、computed和watch的区别\n\ncomputed用声明式的方式描述一个值依赖其他的值，当模板上的属性绑定到计算属性中市，vue会在其他依赖值发生改变导致该计算属性发生改变的时候更新DOM\n\n计算属性computed : （多个属性影响一个属性）\n\n支持缓存，只有依赖数据发生改变，才会重新进行计算\n不支持异步，当computed内有异步操作时无效，无法监听数据的变化\n3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值\n如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed\n5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。\n\n\nwatch监听的是你定义的变量，当你定义的变量的值发生变化时，调用对应的方法（一个数据影响多个数据）\n侦听属性watch：\n\n\n不支持缓存，数据变，直接会触发相应的操作；\n2.watch支持异步；\n3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；\n当一个属性发生变化时，需要执行对应的操作；一对多；\n监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，\n　　immediate：组件加载立即触发回调函数执行，\n　　deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。\n\n九、keep-alive\nkeep-alive是Vue的内置组件，包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。\n十、key\n当有相同标签名的元素切换时，需要通过key特效来设置唯一的值来标记这个标签，防止vue为了效率替换掉同名标签内的内容\n避免同时使用v-if和v-for\n当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。\nctive-class是哪个组件的属性？嵌套路由怎么定义？\nvue-router模块的router-link组件。\n嵌套路由顾名思义就是路由的多层嵌套。 一级路由里面使用children数组配置子路由，就是嵌套路由。\n十一、.$nextTick是什么\nvue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。\n$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM\n十二、directive自定义指令\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\nbind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\ninserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\nupdate：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n我们会在稍后讨论渲染函数时介绍更多 VNodes 的细节。\ncomponentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。\nunbind：只调用一次，指令与元素解绑时调用。\n接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。\n十三、hash和history\n\nhash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取； 特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 hash 模式下:仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。\nhistory模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。\n\n十四、$route和$router的区别\n\n$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。\n$router是’路由实例’对象包括了路由的跳转方法，钩子函数等。\n\n十五、vue响应式原理\n有一个数据a.b,在vue对象实例化过程中，会给a,b通过ES5的defineProperty()方法，添加getter和setter方法，同时vue.js会对模板做编译，解析生成一个指令对象，比如v-text指令，每个指令对象都会关联一个watcher，当对指令对象求值时，就会触发getter，并将依赖收集到watcher中；当再次改变a.b值时，就会触发setter方法，会通知到对应关联的watcher,watcher则再次对a.b求值，计算对比新旧值，当值改变时，watcher会通知到指令，调用指令的update方法，由于指令是对dom的封装，所以会调用原生dom的方法，去更新视图。\n十六、babel工作原理\nbabel是一个转译器，因为它只是把同种语言的高版本规则翻译成低版本规则\nbabel的转译过程也分为三个阶段：parsing、transforming、generating\nES6代码输入 ==》 babylon进行解析 ==》 得到AST\n==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树\n==》 用babel-generator通过AST树生成ES5代码\n十七、render函数\n简单的说，在vue中我们使用模板HTML语法组建页面的，使用render函数我们可以用js语言来构建DOM\n因为vue是虚拟DOM，所以在拿到template模板时也要转译成VNode的函数，而用render函数构建DOM，vue就免去了转译的过程。\n当使用render函数描述虚拟DOM时，vue提供一个函数，这个函数是就构建虚拟DOM所需要的工具。\n十八、vue3.0的新特性\nObject.defineProperty -&gt; Proxy\nObject.defineProperty是一个相对比较昂贵的操作，因为它直接操作对象的属性，颗粒度比较小。将它替换为es6的Proxy，在目标对象之上架了一层拦截，代理的是对象而不是对象的属性。这样可以将原本对对象属性的操作变为对整个对象的操作，颗粒度变大。\nvue3.0中对diff算法进行了优化：\n\nvue2中的diff算法是将虚拟dom进行全量比较\nvue3中diff算法中新增了静态标记，也就是说在于上次虚拟节点进行对比的时候，只对比带有patch flag的节点，并且可以通过flag的信息得知当前节点要对比的具体内容\n\n十九、vue渲染原理\nVue的编译器在编译（template）模板之后，先将模板解析成AST(Abstract Syntax Tree，抽象语法树)，然后再使用AST生成渲染函数，而函数被调用的时候，就会返回一个虚拟DOM树，当我们有了这个虚拟dom树之后，再交给一个patch函数，负责把这些虚拟DOM真正渲染到真实的DOm之上，在这个过程中，Vue有自身的响应式系统来侦测在渲染过程中所依赖到 的数据来源之后，可以通过双向数据绑定，来感知数据的改变，进行重新渲染。\nAST 抽象语法树\nAST不依赖于具体的文法，不依赖于语言的细节，我们将源代码转化为AST后，可以对AST做很多的操作\n抽象语法树（Abstract Syntax Tree）也称为AST语法树，指的是源代码语法所对应的树状结构。也就是说，对于一种具体编程语言下的源代码，通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上。\n","thumbnail":"https://i.loli.net/2021/09/05/zO3UMLb584oiVwN.jpg","plink":"http://example.com/2021/09/05/vue面试题/"},{"title":"前端面试题（上）","date":"2021-09-05T08:52:29.000Z","date_formatted":{"ll":"2021年9月5日","L":"2021/09/05","MM-DD":"09-05"},"updated":"2021-09-05T09:12:43.784Z","content":"typeof和instanceof\nJavascript的数据类型\n\nString、Number、Boolean、null、symbol、undefined、Object、bigint（ES20）\n\n布尔类型里只有这几参数个返回false，其它都为true\nnull和undefined在进行“==”比较是不会进行类型转换\nBoolean(undefined) // false\nBoolean(null) // false\nBoolean(0) // false\nBoolean(NaN) // false\nBoolean(‘’) // false\nBoolean([]); //true\nNumber([]); //0\nNumber({}); // NaN\nNumber(false); //0\n但是  []==false //true\nnull&gt;=0//true\n1234567console.log(null&gt;=0);//true  特殊****console.log(null&gt;0);//falseconsole.log(null==0);//falseconsole.log(&#123;&#125;==false);//falseconsole.log(&#123;&#125;==true);//falseconsole.log(1==true);//trueconsole.log(2==true);//false\n“==”运算符（两个操作数的类型不相同时）\n如果一个值是null，另一个值是undefined，则它们相等\n如果一个值是数字，另一个值是字符串，先将字符串转换为数学，然后使用转换后的值进行比较。\n如果其中一个值是true，则将其转换为1再进行比较。如果其中的一个值是false，则将其转换为0再进行比较。\n如果一个值是对象，另一个值是数字或字符串，则将对象转换为原始值，再进行比较。\ntypeof\n\n\n用于判断数据类型，返回值为7个字符串，分别为string、Boolean、number、function、object、undefined symbol。\n\n\ntypeof对于丰富的对象实例（null，array ，object），只能返回&quot;Object&quot;字符串\n\n\ninstanceof\n判断该对象是谁的实例，基于原型链判断，（A instanceof B）返回的是boolean类型，同时instanceof是对象运算符。\nspa和ssr的区别\n什么是单页面应用（SPA）？\n概念：整个web项目只有一个页面，使用路由机制进行组件之间的切换；\n优点：客户端渲染、数据传输量小、减少服务器端压力、交互/响应速度快、前后端完全分离；\n缺点：首屏加载慢、对SEO不友好，不利于百度，360等搜索引擎收录快照；\n什么是服务端渲染（SSR）？\n概念：将组件或页面通过服务器端生成HTML字符串，再发送到浏览器端渲染；\n优点：对于SEO友好、首屏加载速度快；\n缺点：页面重复加载次数高、开发效率低、数据传输量大、服务器压力大；\nSPA、SSR分别适合什么样的应用场景？\nSPA：对项目性能要求高、页面加载速度快、要求客户端渲染、对SEO要求低；\nSSR：对项目SEO要求高、首次打开响应速度快；\n在vue中可以用nuxt和vue-server-render\n圣杯布局和双飞翼布局的作用和区别\n圣杯布局和双飞翼布局解决的问题是一样的，就是两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。\n圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。\n不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：\n圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。\n双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。\n多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，一共6个；而双飞翼布局子div里用margin-left和margin-right共2个属性，6-2=4），个人感觉比圣杯布局思路更直接和简洁一点。\n简单说起来就是”双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了“，而不是你题目中说的”去掉relative&quot;就是双飞翼布局“。\nhttps://www.cnblogs.com/jiguiyan/p/11425276.html\nevent.target和event.currentTarget\nevent.target 获取的是触发事件的标签元素（比如事件委托）\nevent.currentTarget 获取到的是发起事件的标签元素（始终返回的是绑定事件的元素）\nXHTML和html的区别\n文档结构\n\nXHTML DOCTYPE 是强制性的\nhtml 中的 XML namespace 属性是强制性的\nhtml、head、title 以及 body 也是强制性的\n\n元素语法\n\nXHTML 元素必须正确嵌套\nXHTML 元素必须始终关闭\nXHTML 元素必须小写\nXHTML 文档必须有一个根元素\n\n属性语法\n\nXHTML 属性必须使用小写\nXHTML 属性值必须用引号包围\nXHTML 属性最小化也是禁止的\n\n事件模型\n原始事件模型\n这是一种被所有浏览器都支持的事件模型，对于原始事件而言，没有事件流，事件一旦发生将马上进行处理，有两种方式可以实现原始事件：\n（1）在html代码中直接指定属性值：&lt;button id=&quot;demo&quot; type=&quot;button&quot; onclick=&quot;doSomeTing()&quot; /&gt;　　\n（2）在js代码中为 　document.getElementsById(&quot;demo&quot;).onclick = doSomeTing()\n优点：所有浏览器都兼容\n缺点：1）逻辑与显示没有分离；2）相同事件的监听函数只能绑定一个，后绑定的会覆盖掉前面的，如：a.onclick = func1; a.onclick = func2;将只会执行func2中的内容。3）无法通过事件的冒泡、委托等机制（后面会讲到）完成更多事情。\ndom2事件模型\n(1).事件捕获阶段，(2).事件目标阶段，(3).事件冒泡阶段。\n事件捕获：当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。\n事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。\n事件冒泡：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。\n事件的传播是可以阻止的：\n• 在W3c中，使用stopPropagation（）方法\n　　• 在IE下设置eve.cancelBubble = true；\n　　在捕获的过程中stopPropagation（）；后，后面的冒泡过程就不会发生了。\ngit的基本使用\n在powershell中安装可以使用git命令之后\n\ngit init 初始化仓库\ngit status 展示状态\n\n如果出现please tell me who are you则需要执行下面两条命令\n2.git config user.name “someone”\n3.git config user.email “someone@someplace.com”\n\n\ngit add . 将所有文件放到暂存区\n\n\ngit commit -m “init my project”  提交项目到本地git\n\n\ngit remote add origin https://github.com/WLJ456/Vue.git   远程连接github账号\n\n\ngit push -u origin master  上传项目到github。输入账号密码之后即可上传。\n\n\n修改之后不用在运行git 命令 直接使用vscode自带功能暂存到本地，并推送到github\n\n\n克隆获取代码：git clone -b main  https://github.com/WLJ456/blogVue.git F:\\asus\\Desktop\\gitsave   注意 -b是获取其他分支的方式，如果没有-b则获取默认分支。\n\n\ngit branch text //创建 text分支\n\n\ngit checkout text //切换到 text分支\n\n\ngit push --set-upstream origin text //text分支已经上传到了 github\n\n\nVscode 本身自带 点击源代码管理可进行一定操作\n将分支进行合并：\n1.先切换到主分支 git checkout master\n2.在主分支上进行合并git merge text\n3.如有改动的界面，会弹出界面\n4.最后git push推送到远程分支）\ngit基本操作链接\nwebpack模块热替换\n模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面\n在应用程序中,通过以下步骤，可以做到在应用程序中置换(swap in and out)模块：\n\n应用程序代码要求 HMR runtime 检查更新。\nHMR runtime（异步）下载更新，然后通知应用程序代码。\n应用程序代码要求 HMR runtime 应用更新。\nHMR runtime（同步）应用更新。\n你可以设置 HMR，以使此进程自动触发更新，或者你可以选择要求在用户交互时进行更新。\n\n一、event loop 事件循环：\n浏览器 eventloop\n\neventloop事件循环是一种执行模型一种运行机制，在不同的地方有不同的实现，主要分为浏览器的event loop和nodejs的event loop；在事件循环中有两个重要的概念，宏队列和微队列\n首先，对于浏览器的event loop来说，是html5定义的规范，但是是在浏览器实现的，在浏览器中：宏队列主要包括settimeout和setinterval，微队列主要有promise。主要执行过程是：\n浏览器首先会将同步任务执行完毕，这时调用栈会被清空\n之后会从微任务队列中取出位于队首的回调任务，遵从先进先出的原则依次放入调用栈中执行，直到栈空，如果此时回调函数中又生成了微任务，将其放在队尾等待调用\n当微任务队列为空的时候，这时将调用宏队列，将队首任务放入调用栈执行；（一次只能执行一个宏队列）如果宏任务中产生了微任务，就去先调用微任务，再去调用下一个宏任务\n然后重复步骤，这就是浏览器的eventloop\n\nnodejs eventloop\nnodejs的eventloop是基于libuv实现的，在事件循环执行宏队列时，nodejs的回调任务有6个阶段，timer（settimeout和setinterval）、I/O callback阶段、idle，prepare阶段、poll阶段、check阶段、close 阶段。这6个阶段构成了4个宏队列分别是：Timers Queue、IO Callback Queue、Check Queue、close callback Queue；\n-nodejs 事件循环和浏览器事件循环最主要的区别就是：浏览器可以看做一个宏队列一个微队列；而nodejs是4个宏队列和2个队列，所以就会有队列的执行先后问题，在微队列中首先会执行NextTick Queue（process.nexttick） 在执行传统的微队列比如promise等，在执行宏队列任务时，需要将每一类宏队列的任务全部执行完毕，才执行对应产生的微队列。\n二、浏览器缓存：强缓存和协商缓存\nHTTP报文就是浏览器和服务器间通信时发送及响应的数据块。\n浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。\n报文信息主要分为两部分\n1.包含属性的首部(header)————————–附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中\n2.包含数据的主体部分(body)———————–HTTP请求真正想要传输的部分\n强缓存\n当我在没有缓存，第一次请求服务器的时候，服务器会将数据和缓存规则一并返回，缓存规则存放在响应头中，  主要是Expires/Cache-Control来表明缓存失效规则，因为在expires中缓存到期时间是服务器的时间，而客户端和服务器的时间可能存在差异，所以先在基本上都使用的cache-control，强缓存主要设置max-age属性，即到期时间，在这个期间客户端访问数据均走缓存\n协商缓存\n在第一次请求服务器时，服务器会返回资源，并且返回一个资源的缓存标识，一起存到浏览器的缓存数据库。\n当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后判断标识是否匹配，\n如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器；\n如果缓存标识匹配，表示资源没有更新，并且返回 304 状态码，浏览器就读取本地缓存服务器中的数据。\n在学号是协商缓存中主要有：\nlast-Modified/If-Modified-Since ：服务器返回的资源最后修改时间\netag/if-none-match：资源在服务器的唯一标识\n重绘和重排\n\n当dom的变化引发了元素几何属性的改变，比如元素的高宽，元素位置啊，导致浏览器重新计算元素的几何属性，并重新构建渲染树，这个过程称为重排\n完成重排后，要将构建的渲染树渲染到屏幕，这个过程叫重绘\n简单来说，重排负责元素的几何属性，而重绘负责元素样式更新，重排必定带来重绘\n\n重排触发机制：\n\n添加或者删除可见dom\n元素位置\n元素本身尺寸\n内容改变\n页面渲染器初始化\n\n优化：虚拟dom和mvvm\n三、节流和防抖\n防抖：对于短时间内，连续出发的事件，防抖的含义是让某个时间限内，事件处理函数只执行最后一次或最开始的第一次。（如果在期限内又被触发，则会重新计时）\n1234567891011//实现防抖函数        function debounce(fn, timer) &#123;            let time = null;            return function () &#123;            var context = this, agrs = arguments;                if (time) &#123;                    clearTimeout(time)                &#125;                time = setTimeout(fn.apply(context,agrs), timer)            &#125;        &#125;\n防抖(debounce)\nsearch搜索联想，用户在不断输入值时，用防抖来节约请求资源。\nwindow触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次\n节流：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。\n123456789101112131415//实线节流函数       function throttle(fn, timer) &#123;           let flag = true           return function () &#123;            var context = this, agrs = arguments;               if (!flag) &#123;                   return false               &#125; //在一段时间内flag始终为false               flag = false               setTimeout(() =&gt; &#123;                  fn.apply(context, agrs);                   flag = true;               &#125;, timer)           &#125;       &#125;\n节流(throttle)\n鼠标不断点击触发，mousedown(单位时间内只触发一次)\n监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断\n三、web worker\nWeb Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。\nWeb Worker 有以下几个使用注意点。\n（1）同源限制\n分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。\n（2）DOM 限制\nWorker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。\n（3）通信联系\nWorker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。\n（4）脚本限制\nWorker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。\n（5）文件限制\nWorker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。\n四、原型链\nprototype 在JavaScript中，每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。\nproto 这是每个对象(除null外)都会有的属性，叫做__proto__，这个属性会指向该对象的原型。\n\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止\n每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。\n\n原型链污染\n原型污染是指将属性注入现有JavaScript语言构造原型（如对象）的能力。\n123456789101112131415161718// foo是一个简单的JavaScript对象let foo = &#123;bar: 1&#125;// foo.bar 此时为1console.log(foo.bar)// 修改foo的原型（即Object）foo.__proto__.bar = 2// 由于查找顺序的原因，foo.bar仍然是1console.log(foo.bar)// 此时再用Object创建一个空的zoo对象let zoo = &#123;&#125;// 查看zoo.barconsole.log(zoo.bar)最后，虽然zoo是一个空对象&#123;&#125;，但zoo.bar的结果居然是2：\n在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象，所有JavaScript对象通过原型链继承，都会继承Object.prototype上的属性，这种攻击方式就是原型链污染。\n原型链污染主要是因为攻击者可以设置__proto__的值，解决方法：\n123456var x=Object.create(null);Object.getPrototypeOf(x)==null;//true一些不支持Object.create函数的旧的js环境可能支持__proto__属性，对象字面量也支持初始化一个原型链为null的新对象。var x=&#123;__proto__:null&#125;;x instanceof Object;//false\n五、new一个构造函数的过程\n\n创建一个新对象，将它的引用赋值给this，继承函数的原型\n通过this将构造函数的属性添加给这个对象\n最后返回这个this指向的新对象，也就是实例\n\n1234567let newMethods = function (Parent, ...rest) &#123;    let child = Object.create(Parent.prototype);    let ruselt = Parent.apply(child, rest)    return typeof result === &#x27;object&#x27; ? result : child;&#125;const child = newMethods(ssss, &quot;zdd&quot;);\n六、promise原理\n同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有等主线程任务执行完毕，&quot;任务队列&quot;开始通知主线程，请求执行任务，该任务才会进入主线程执行。\n\n首先promise解决的异步问题，同时他的应用场景主要是解决回到地狱的问题，promise 可以实现在多个请求发送完成后，再得到或者处理某个结果，\npromise的原理：promise主要三个状态 pending、Fulfilled、rejected，当promise构造函数需要传入一个函数，函数中有两个参数分别是resolve和reject，在promise中有一个then，他的主要功能是当promise对象状态发生改变时执行相应操作，当然promise是基于发布订阅者模式实现的\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function myPromise(constructor) &#123;    let self = this;    self.status = &quot;pending&quot;;    self.value = undefined;    self.reason = undefined;    //定义观察数组    self.onFullfilledArray = []    self.onRejectedArray = []    function resolve(value) &#123;        if (self.status == &quot;pending&quot;) &#123;            self.value = value;            self.status = &quot;resolved&quot;            self.onFullfilledArray.forEach(fn =&gt; &#123;                fn(self.value)            &#125;);        &#125;    &#125;    function reject(reason) &#123;        if (self.status == &quot;pending&quot;) &#123;            self.reason = reason;            self.status = &quot;rejected&quot;            self.onRejectedArray.forEach(fn =&gt; &#123;                fn(self.reason)            &#125;)        &#125;    &#125;    try &#123;        constructor(resolve, reject);    &#125; catch (e) &#123;        reject(e);    &#125;&#125;myPromise.prototype.then = function (onFullfilled, onRejected) &#123;    let self = this;    switch (self.status) &#123;        case &quot;pending&quot;:            self.onFullfilledArray.push(function () &#123;                onFullfilled(self.value)            &#125;)            self.onRejectedArray.push(function () &#123;                onRejected(self.reason)            &#125;)            break;        case &quot;resolved&quot;:            onFullfilled(self.value);            break;        case &quot;rejected&quot;:            onRejected(self.reason);            break;        default:    &#125;&#125;new myPromise((resolve, reject) =&gt; &#123;    console.log(123);    // resolve(222)    setTimeout(function () &#123;        resolve(222)    &#125;, 2000)&#125;).then(data =&gt; &#123;    console.log(data);&#125;)\n七、Content-type\n服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。\napplication/x-www-form-urlencoded\n\n这应该是最常见的 POST 提交数据的方式了。浏览器的原生  表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。\n\nmultipart/form-data\n\n这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让  表单的enctype 等于 multipart/form-data。\n\napplication/json\n\n通过序列化json字符串的方式进行编码,可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。\n\ntext/xml\n\n忽略xml头所指定bai编码du格式而默认采用zhius-ascii编码\n\n八、mouseover和mouseleave的区别\n\nmouseover：只要鼠标指针移入事件绑定的元素及其子元素，都会触发mouseover事件\nmouseleave：只有鼠标指针移入事件绑定的元素时，才会触发mouseleave事件\n\n九、canvas和svg\n一句话总结：都是2D做图，svg是矢量图，canvas是位图。Canvas 是逐像素进行渲染的，适合游戏。\ncanvas：\n\n依赖分辨率\n不支持事件处理器\n弱的文本渲染能力\n能够以 .png 或 .jpg 格式保存结果图像\n最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n\nsvg（可缩放矢量图形）：\n\n不依赖分辨率\n支持事件处理器\n最适合带有大型渲染区域的应用程序（比如谷歌地图）\n复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n不适合游戏应用\n\n十、clientHeight、offsetHeight、scrollHeight\n\nclientHeight：可理解为内部可视区高度，样式的height+上下padding\noffsetHeight：在clientHeight上包含了boder-Width的高度和滚动条\nscrollHeight： 元素内容的实际距离，包括了隐藏部分的内容高度\nclientTop：容器内部相对于容器本身的top偏移，实际就是 上border-width\noffsetTop：距离最近的开启了position定位的元素的距离，若无就是距离body的高度。 offsetTop = top + margin-top + border-top\nscrollTOp：滚动内容被隐藏的高度\n\n十一、线程和进程\n\n线程：线程是进程的基本执行单元，一个进程中的所有任务都在线程中执行，进程要想执行任务，必须得有线程，进程至少要有一条线程\n进程：进程是指在系统中正在运行的一个应用程序\n每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存\n\n区别：\n\n地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。\n资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。\n一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。\n进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程\n执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。\n线程是处理器调度的基本单位，但是进程不是。\n\n十二、普通函数和箭头函数的区别\n\n箭头函数是不能用于构造函数的\n箭头函数中的this是指向其上下文中的this，而普通函数中的this指向其调用对象\n箭头函数不能当做generator函数，不能使用yield关键字\n箭头函数没有prototype属性\n箭头函数不绑定arguments，用rest参数…解决\n\nthis\n面向对象语言中 this 表示当前对象的一个引用。\n但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。\n\n在方法中，this 表示该方法所属的对象。\n如果单独使用，this 表示全局对象。\n在函数中，this 表示全局对象。\n在函数中，在严格模式下，this 是未定义的(undefined)。\n在事件中，this 表示接收事件的元素。\n类似 call() 和 apply() 方法可以将 this 引用到任何对象。\n\n十三、var let const\n\nvar定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。同时存在变量提升\nlet定义的变量，同一块级作用域不能重复定义，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。\nconst用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。\n\n注：let和const存在暂时性死区，只是创建过程提升，提前访问报错 xx is not defined，这其实是暂时性死区的表现，也就是说只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。\n十四、null和undefined的区别\nnull表示&quot;没有对象&quot;，即该处不应该有值\n（1） 作为函数的参数，表示该函数的参数不是对象。\n（2） 作为对象原型链的终点。\nundefined表示&quot;缺少值&quot;，就是此处应该有一个值\n（1）变量被声明了，但没有赋值时，就等于undefined。\n（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n（3）对象没有赋值的属性，该属性的值为undefined。\n（4）函数没有返回值时，默认返回undefined。\n十五、JSON.stingify深拷贝的缺点\n\n如果对象中有时间对象，之后将字符串在返回成对象的时候，时间对象任然是字符串\n如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；\n如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；\n如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null\nJSON.stringify()只能序列化对象的可枚举的自有属性\n\n十六、require和import\n\nrequire是commonjs规范引入的，而import是Es6引入的\nrequire是运行时调用，而import是编译时调用\nCommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用\n在commom.js 中module.export 之后 导出的值就不能再变化，但是在es6的export中是可以的\n\n十七、常见选择器\n\n标签选择器\nid选择器\n类选择器\n属性选择器\n通用选择器\n兄弟选择器\n后代选择器\n并集选择器\n\nimportant&gt;行内&gt;id&gt;class&gt;标签\n十八、clientX/clientY、screenX/screenY、pageX/pageY、offsetX/offsetY\n\nclientX/clientY：返回事件触发时鼠标相对于元素视口的X/Y坐标 (这里的元素视口实际上代指就是浏览器，clientX是鼠标距离浏览器左边框的距离，clientY是鼠标距离浏览器上边框的距离。)\nscreenX/screenY:返回事件触发时鼠标相对于屏幕 的X/Y坐标\npageX/pageY：返回事件触发时鼠标相对于文档 X和Y坐标\noffsetX/offsetY：返回事件触发时鼠标相对于事件指向元素 的X和Y坐标（假设有一个元素p当鼠标进入元素中触发事件时这是offsetX指的就是鼠标到P元素左边的距离。但是这个属性并不是标准属性，因此IE和chrome对这个属性的支持并不一样。在chrome中offsetX和offsetY的值均为整数，而在IE中值为小数形式，并且如果元素有border属性也会影响到offsetY的计算。）\n\n十九、常见布局方式\n\n固定布局：pc端常见的px为单位的布局方式，使用于pc端，但不适用于手机端；\n流式布局：也叫百分比布局，具有较好的解决自适应需求，但是缺点就是不够灵活，添加元素时，需要修改其他元素的百分比。\nflex布局：也叫弹性布局，会根据页面剩余的宽度自动分配空间，比较合适应用程序的组件和小规模的布局。\n媒体查询和rem布局：现在比较流行的布局，可以根据不同设备的宽度加载不同的css样式。主要是通过更改不同的font-size大小来更改样式，可以实现移动端的响应式\n响应式布局：主要是通过媒体查询的方式，来执行不同的css代码\n\n二十、resultFul的特点\nrest的含义\n\n每一个url代表的一种资源\n客户端和服务端，是传递这种资源的表现层\n客户端通过http的put、get、post、delete的方式，来进行服务端资源进行操作，从而实现表现层的状态转换\n\nrestful的原则\n\nc-s架构\n无状态 客户端每次需要携带认证信息让服务端识别\n统一的接口 rest架构的核心，统一的接口对于restful服务十分重要，客户端只需要关注实现接口就可以了，接口的可读性加强，使用人员方便调用，\n一致的数据格式 （xml、json、或者返回状态码）\n系统分层和可缓存\n\n二十一、CDN网站加速\n\nCDN全称叫做内容分发网络，是通过主动加入内容管理层和全局负载均衡，尽可能的避开网络上有可能影响数据传输速度和稳定性的环节；\ncdn网站加速是一种新型的网络构建模式，使用CDN加速之后，远程用户访问会通过负载均衡技术自动选择最快的Cache服务器，由此来缩短访问的响应时延。\n\nCDN优势\n\ncdn节点解决跨地域和跨运营商的问题，降低了访问时延\n大部分请求都会在CDN边缘节点，CDN可以起到分流的作用，减轻了服务器的压力\n\nCDN的缺点\n\n当服务器更新资源的时候，如果cdn节点上的数据没有更新，那么用户会出现访问异常（因为cdn更新是具有周期性的，又称回源，可以进行手动刷新cdn的方式）\n\n二十二、js动画和css动画的区别\nCSS动画 （GUI解析）\n\n优点：性能较好，浏览器会对CSS动画做一些优化\n代码相对简单。\n\n\n\n缺点：\n在动画上控制不够灵活；\n兼容性不好；\n部分动画无法实现（如滚动动画，视差滚动等）\n\nJavaScript动画\n\n控制能力强，动画效果丰富， 可以单帧的控制、变换； - 大部分时候不存在兼容性问题。\n缺点：\n干扰主线程导致阻塞，造成丢帧情况\n代码复杂度高\n\nCSS动画流畅的原因\n渲染线程分为main thread(主线程)和compositor thread(合成器线程)。\n如果CSS动画只是改变transform和opacity，这时整个CSS动画得以在compositor thread完成（而JS动画则会在main thread执行，然后触发compositor进行下一步操作）\n在JS执行一些昂贵的任务时，main thread繁忙，CSS动画由于使用了compositor thread可以保持流畅。\n在主线程中，维护了一棵Layer树（LayerTreeHost），管理了TiledLayer，在compositor thread，维护了同样一颗LayerTreeHostImpl，管理了LayerImpl，这两棵树的内容是拷贝关系。因此可以彼此不干扰，当Javascript在main thread操作LayerTreeHost的同时，compositor thread可以用LayerTreeHostImpl做渲染。当Javascript繁忙导致主线程卡住时，合成到屏幕的过程也是流畅的。\n二十三、requestAnimationframe\nrequestAnimationFrame传入的回调函数在页面重绘之前调用；\n\n由系统来决定回调函数的执行机制。在运行时浏览器会自动优化方法的调用。\nrequestAnimationFrame 不需要像\nsetTimeout 那样传递时间间隔，而是浏览器通过系统获取并使用显示器刷\n新频率\n提升性能，防止掉帧\nrequestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧\n在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。\n\n二十四、tcp和http的关系\nTCP 是传输层协议，HTTP 是应用层协议，HTTP 运行在 TCP 之上\n二十五、TCP三次握手和四次回收\n三次握手\n\n起初两端都处于closed关闭状态，这是客户端将标志位SYN设置为1，随机产生序列号seq=x，将数据包发送给服务端，客户端的状态变为SYNSEND状态\n服务端收到数据包之后，由标志位SYN等于1得知客户端需要建立连接，服务端将标志位SYN和ACk都置于1，同时将确认号ack置为x+1，再随机产生于一个序列号seq=y，将数据包返回给客户端，这是服务端进入SYNrevd状态；此时操作系统为TCP连接分配TCP缓存和变量\n客户端收到确认后，检查确认号ack是否为x+1，标志位ACK是否为1，如果是，则将标志位ACK置为1，确认号ack=y+1，返回给服务端，服务端收到之后查看确认号是否为y+1，标志位ACK是否为1，如果正确，则连接成功，服务端和客户端进入established状态，开始通信。\n（第三次握手是为了防止已经失效的连接请求报文突然又传到了服务器，因而产生错误。）\n\n四次挥手\n\n第一次挥手：主动关闭方发送第一个包，其中FIN标志位为1，发送顺序号seq为X。\n第二次挥手：被动关闭方收到FIN包后发送第二个包，其中发送顺序号seq为Z，接收顺序号ack为X+1。\n第三次挥手：被动关闭方再发送第三个包，其中FIN标志位为1，发送顺序号seq为Y，接收顺序号ack为X。\n第四次挥手：主动关闭方发送第四个包，其中发送顺序号为X，接收顺序号为Y。至此，完成四次挥手。\n\n为什么要进行四次挥手\n因为双方彼此建立了连接，双方都要释放自身的连接，A向B发出一个释放连接请求，他要释放连接表明不再像B放送数据了，此时B收到A的释放连接请求，给A放松确认，A不再向B发送数据，它处于fin-wait-2状态，但是此时B还可以想A进行数据的传送。此时B向A发送一个断开连接的请求，A收到后发送确认，B收到后关闭。\n二十六、闭包\n指有权访问其他函数内部变量的函数叫做闭包，简而言之就是闭包内的作用域不会不释放。简单来说闭包函数就是一个函数中的函数\n\n闭包的作用：\n1.实现共有变量。\n2.可以用作缓存。\n3.可以实现函数封装，及属性私有化。\n4.模块化开发，防止污染全局变量。\n缺点：\n常驻内存 会增大内存的使用量 使用不当会造成内存泄露\n\n二十七、generator函数\n\n语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态\n换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\nnext的参数会作为上一个yield的返回值\n\n二十八、await 和async\n简单来说他是Generator 函数的语法糖，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await\n\n就是将 Generator 函数和自动执行器，包装在一个函数里\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\nawait函数必须在async函数之中；\n如果await等待的不是一个promise对象，那么await的运算结果就是后面的值\n如果await等待的是一个promise对象，那么他会阻塞后面的代码等到resolve的值最为他的值\n\n二十九、get和post在缓存方面的区别\nget请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。\npost不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。\n三十、get和post的区别\n\nget参数通过url传递，post放在request body中\nget请求在url中传递的参数是有长度限制的（2k-8k），而post是没有的\nget传参会具有安全问题，因为参数时暴露在url中，所以不能用来传递敏感信息\nget 请求使用url编码，post使用多种编码\nget请求会浏览器主动ache，post则不会\nget请求会保存在浏览器历史记录，而post中的参数不会被保留\nget和post本质上都是tcp连接，get产生一个tcp数据包，post会产生两个tcp数据包。\n\n三十一 垃圾回收机制\n一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这\n几个对象也是垃圾，也要被清除。\nJS中最常见的垃圾回收方式是标记清除。\n工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。\n工作流程：\n\n\n垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。\n\n\n去掉环境中的变量以及被环境中的变量引用的变量的标记。\n\n\n再被加上标记的会被视为准备删除的变量。\n\n\n垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。\n\n\n引用计数 方式\n工作原理：跟踪记录每个值被引用的次数。\n工作流程：\n\n\n声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。\n\n\n同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.\n\n\n当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.\n\n\n当引用次数变成0时，说明没办法访问这个值了。\n\n\n当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。\n\n\n三十二.什么情况会引起内存泄漏\n虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。\n\n意外的全局变量引起的内存泄漏。\n\n原因：全局变量，不会被回收。\n解决：使用严格模式避免。\n\n闭包引起的内存泄漏\n\n原因：闭包可以维持函数内局部变量，使其得不到释放。\n解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。\n\n没有清理的DOM元素引用\n\n原因：虽然别的地方删除了，但是对象中还存在对dom的引用\n解决：手动删除。\n\n被遗忘的定时器或者回调\n\n原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。\n解决：手动删除定时器和dom。\n\n子元素存在引用引起的内存泄漏\n\n原因：div中的ul li  得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。\n解决：手动删除清空。\n三十三、前端常见兼容性\n\n不同浏览器的标签默认的外补丁和内补丁不同\n\n问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。\n碰到频率:100%\n解决方案：CSS里    *{margin:0;padding:0;}\n备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。\n2.图片默认有间距\n解决方案：使用float 为img 布局\n3.边距重叠问题；当相邻两个元素都设置了margin 边距时，margin 将取最大值，舍弃最小值；\n解决方案：为了不让边重叠，可以给子元素增加一个父级元素，并设置父级元素为overflow:hidden；\n4.td 自动换行的问题\n问题：table 宽度固定，td 自动换行\n解决：设置 Table 为 table-layout: fixed，td 为 word-wrap: break-word\n浏览器内核\n\ntrident  ------ie\nedgeHTMl ------edge\nwebkit-----safari\nblink-----谷歌\ngecko------火狐\npresto-----opera  （03年之后采用，blink）\n\n渐进增强和优雅降级\n1.什么是渐进增强\n在网页开发中，渐进增强认为应该专注于内容本身。一开始针对低版本的浏览器构建页面，满足最基本的功能，再针对高级浏 览器进行效果，交互，追加各种功能以达到更好用户体验,换句话说，就是以最低要求，实现最基础功能为基本，向上兼容。以css为例，以下这种写法就是渐进增强。\n2.什么是优雅降级\n在网页开发中，优雅降级指的是一开始针对一个高版本的浏览器构建页面，先完善所有的功能。然后针对各个不同的浏览器进行测试，修复，保证低级浏览器也有基本功能 就好，低级浏览器被认为“简陋却无妨 (poor, but passable)” 可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较 大的错误之外，其它的差异将被直接忽略。也就是以高要求，高版本为基准，向下兼容。同样以css为例，优雅降级的写法如下。\ncsrf和xss\n\ncsrf：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送恶意请求，之后再攻击者用用户的名义操作数据库，防御方式的话：使用验证码，检查https头部的referer，使用token\nxss：跨站脚本攻击，攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览器看到的时候进行攻击，反射型，不存储在数据库中，往往表现为将攻击代码放在url地址中， 防御方式：cooikes设置为httponly，禁止脚本访问cookie，对用户的输入进行检查，进行特殊字符的过滤。\n\nVideo和audio的方法和事件\n\n方法：load() play() pause()\n事件：play() playing() pause() seeked() seeking() abort()当音频/视频的加载已放弃时触发\n\nweb应用作用域\nWeb程序对象作用域： 常用的有三个：请求作用域，会话作用域，应用上下文。 请求作用域req范围最小，需要的资源最少，作用当前请求 session会话作用于本次对话，每个对话都有JSessionID， ServletContext作用域范围大：web应用中所有都能够访问，生命周期和web容器一样长，维护所需资源多。 在满足需求内耗费的资源越小越好\nbackground-position属性\nBackground-position属性\n用处：配合background-image属性一起使用，用于设置背景图片在盒子中的位置\n参数：xpos ypos |x% y% |x y三种,\n如果只写第一个水平方向的参数，第二个垂直方向的参数会默认为：\ncenter|50%|容器高度的一半px\nXpos：规定水平方向的对齐方式,值有left,right,center\nYpos：规定垂直方向的对齐方式,值有top,bottom,center\nx%:规定图片水平方向的距离。\n你会不会以为这个x%就是父级容器宽度的x%？那你就想错了哦，这里的x%指的是父级容器的宽度减去图片的宽度后的差值的x%。\n举个栗子：background-position：50%，20%；\n图片的宽度为     imgwidth：100px；高度为     imgheight：100px；\n容器的宽度为     conwidth：200px；高度为     conheight：200px；\n那么此时图片的左顶点距离容器的左顶点的水平距离就是(conwidth-imgwidth)50%=50px,而不是conwidth50%=100px；(很好理解的吧，不然盒子宽度200px，图片宽度100px，又距离左边100px，岂不是50%没实现水平居中而紧靠右了吗？)\n由此也可以算出图片的左顶点距离容器的左顶点的垂直距离为20px\ny%:对应x%\nx:图片距离容器水平方向距离\ny:图片距离容器垂直方向距离\njs设计模式\n1.单例模式\n保证一个类仅有一个实例，并提供一个访问它的全局访问点\n1234567891011var singlon = (function () &#123;    var instance = null;    let createdSing = function (name) &#123;        if (instance) &#123;            return instance        &#125;        this.name = name        instance = this    &#125;    return createdSing&#125;)()\n2.工厂模式\n工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。\n因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量同时解决了重复实例化的问题，缺点是无法清楚他们是哪个对象的实例。\n1234567891011function Animal(opts)&#123;    var obj = new Object();    obj.color = opts.color;    obj.name= opts.name;    obj.getInfo = function()&#123;        return &#x27;名称：&#x27;+ onj.name+&#x27;， 颜色：&#x27;+ obj.color;    &#125;    return obj;&#125;var cat = Animal(&#123;name: &#x27;波斯猫&#x27;, color: &#x27;白色&#x27;&#125;);cat.getInfo();\n3.构造函数模式\nECMAScript中的构造函数可用来创建特定类型的对象，像Array和Object这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象的属性和方法。使用构造函数的方法，既解决了重复实例化的问题，又解决了对象识别的问题。\n12345678910function Animal(name, color)&#123;    this.name = name;    this.color = color;    this.getName = function()&#123;        return this.name;    &#125;&#125;// 实例一个对象var cat = new Animal(&#x27;猫&#x27;, &#x27;白色&#x27;);console.log( cat.getName() );\n4.订阅/发布模式\n订阅发布模式又称为观察者模式，定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有的观察者对象。\n发布者发出通知 =&gt;主题对象收到通知并推送给订阅者 =&gt; 订阅者执行相应的操作。\n\n初始化发布者、订阅者。\n订阅者需要注册到发布者，发布者发布消息时，依次向订阅者发布消息。\n\n1234567891011121314151617181920212223242526272829303132333435// 一个发布者 publisher，功能就是负责发布消息 - publish       var pub = &#123;           publish: function () &#123;               dep.notify();           &#125;       &#125;       // 多个订阅者 subscribers， 在发布者发布消息之后执行函数       var sub1 = &#123;            update: function () &#123;               console.log(1);           &#125;       &#125;       var sub2 = &#123;            update: function () &#123;               console.log(2);           &#125;       &#125;       var sub3 = &#123;            update: function () &#123;               console.log(3);           &#125;       &#125;       // 一个主题对象       function Dep() &#123;           this.subs = [sub1, sub2, sub3];       &#125;       Dep.prototype.notify = function () &#123;           this.subs.forEach(function (sub) &#123;               sub.update();           &#125;);       &#125;       // 发布者发布消息， 主题对象执行notify方法，进而触发订阅者执行Update方法       var dep = new Dep();       pub.publish();\n5.mixin模式\nmixin模式就是一些提供能够被一个或者一组子类简单继承功能的类,意在重用其功能,通过javascript特有的原型链属性，将功能引用复制到原型链上，达到功能的注入。\n优点和缺点\nMixin支持在一个系统中降解功能的重复性,增加功能的重用性.在一些应用程序也许需要在所有的对象实体共享行为的地方,我们能够通过在一个Mixin中维护这个共享的功能,来很容易的避免任何重复,而因此专注于只实现我们系统中真正彼此不同的功能。\n也就是说,对Mixin的副作用是值得商榷的.一些开发者感觉将功能注入到对象的原型中是一个坏点子,因为它会同时导致原型污染和一定程度上的对我们原有功能的不确定性.在大型的系统中,很可能是有这种情况的。\n6.装饰者模式\n什么是装饰者模式？\n定义：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。\n主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。\n何时使用：在不想增加很多子类的情况下扩展类。\n如何解决：将具体功能职责划分，同时继承装饰者模式。\n应用实例： 1、孙悟空有 72 变，当他变成&quot;庙宇&quot;后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。\n优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n缺点：多层装饰比较复杂。\n使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。\n注意事项：可代替继承。\ncss盒子模型\n页面就是由一个个盒模型堆砌起来的，每个HTML元素都可以叫做盒模型，盒模型由外而内包括：边距（margin）、边框（border）、填充（padding）、内容（content）。它在页面中所占的实际宽度是margin + border + paddint + content 的宽度相加。\n\n标准盒模型：width只包括content     box-sizing：content-box\n怪异盒模型（IE模型）：IE模型的width包括content、padding和border  box-sizing：border-box\n\n继承方式\n1.原型链继承\n核心： 将父类的实例作为子类的原型\n123456789101112function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = &#x27;cat&#x27;;//　Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.eat(&#x27;fish&#x27;));console.log(cat.sleep());console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true\n特点：\n\n非常纯粹的继承关系，实例是子类的实例，也是父类的实例\n父类新增原型方法/原型属性，子类都能访问到\n简单，易于实现\n\n缺点：\n\n创建子类实例时，无法向父类构造函数传参\n要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中\n无法实现多继承\n\n2.构造继承\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n1234567891011function Cat(name)&#123;  Animal.call(this);  this.name = name || &#x27;Tom&#x27;;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true\n特点：\n\n\n解决了1中，子类实例共享父类引用属性的问题\n\n\n创建子类实例时，可以向父类传递参数\n\n\n可以实现多继承（call多个父类对象）\n缺点：\n\n\n实例并不是父类的实例，只是子类的实例\n\n\n只能继承父类的实例属性和方法，不能继承原型属性/方法\n\n\n无法实现函数复用，每个子类都有父类实例函数的副本，影响性能(*)\n\n\n3.实例继承\n为父类实例添加新特性，作为子类实例返回\n123456789101112function Cat(name)&#123;  var instance = new Animal();  instance.name = name || &#x27;Tom&#x27;;  return instance;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false\n特点：\n不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果\n缺点：\n实例是父类的实例，不是子类的实例\n不支持多继承\n4.拷贝继承\n1234567891011121314function Cat(name)&#123;  var animal = new Animal();  for(var p in animal)&#123;    Cat.prototype[p] = animal[p];  &#125;  Cat.prototype.name = name || &#x27;Tom&#x27;;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true\n特点：\n支持多继承\n缺点：\n效率较低，内存占用高（因为要拷贝父类的属性）\n无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）\n5.组合继承\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n12345678910111213function Cat(name)&#123;  Animal.call(this);  this.name = name || &#x27;Tom&#x27;;&#125;Cat.prototype = new Animal();Cat.prototype.constructor = Cat;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true\n特点：\n\n弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法\n既是子类的实例，也是父类的实例\n不存在引用属性共享问题\n可传参\n函数可复用\n缺点：\n\n调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\n6.寄生继承\n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n1234567891011121314151617181920function Cat(name)&#123;  Animal.call(this);  this.name = name || &#x27;Tom&#x27;;&#125;(function()&#123;  // 创建一个没有实例方法的类  var Super = function()&#123;&#125;;  Super.prototype = Animal.prototype;  //将实例作为子类的原型  Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //trueCat.prototype.constructor = Cat; // 需要修复下构造函数\nES5和ES6继承最大的区别就是在于：\n1.ES5先创建子类，在实例化父类并添加到子类this中\n　　　　2.ES6先创建父类，在实例化子集中通过调用super方法访问父级后，在通过修改this实现继承\n\n注意：super关键字指代父类的实例，即父类的this对象。\n注意：在子类构造函数中，调用super后，才可使用this关键字，否则报错。\n\n长连接、短连接、长轮询和WebSocket\n\n\n长连接：从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：\nConnection:keep-alive\n在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\n\n\n短连接：在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。\n\n\n长轮询：（我自己的理解）客户端不断发送请求，获取服务器上的数据。在长轮询机制中，客户端像传统轮询一样从服务器请求数据。然而，如果服务器没有可以立即返回给客户端的数据，则不会立刻返回一个空结果，而是保持这个请求等待数据到来（或者恰当的超时），之后将数据作为结果返回给客户端。\n\n\nWebSocket：是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，客户端发送一次http websocket请求，服务器响应请求，双方建立持久连接，并进行双向数据传输，后面不进行HTTP连接，而是使用TCP连接。\n\n\nhttp2.0的优点\n\n提升访问速度，请求资源所需的时间更少，访问速度更快\n允许多路复用：允许通过单一的http2.0的连接发送多重请求-响应信息，改善了在http1.1中，在同一时间，针对同一域名的请求有一定的数量限制，超过限制会被阻塞\n首部压缩\n服务端推送\n\nfor…in和Object.keys和reflect.ownKeys和Object.getOwnPropertySymbols  和Object.getOwnPropertyNames\n\nfor in  循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）\nObject.keys  返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）\nObject.getOwnPropertyNames  返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。\nObject.getOwnPropertySymbols  返回一个数组，包含对象自身的所有Symbol属性。\nReflect.ownKeys  返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举\n\n双边距重叠问题\n同一个BFC（块级格式化上下文）内部，相邻的两个盒子上下外边距（margin）会发生重叠。重叠之后的结果是这两个盒子相邻部分的垂直外边距取两者中较大的那个数值。\njs跨域方式\n1.通过jsonp跨域\nJSONP包含两部分：回调函数和数据。\n回调函数：当响应到来时要放在当前页面被调用的函数。\n数据：就是传入回调函数中的json数据，也就是回调函数的参数了。\n2.通过document.domain+iframe来跨子域(只有在主域相同的时候才能使用该方法)\n浏览器同源策略限制：\n（1）不能通过ajax的方法去请求不同源中的文档。\n（2）浏览器中不同域的框架之间是不能进行js的交互操作的。\n所以，在不同的框架之间（父子或同辈），是能够获取到彼此的window对象的，但不能使用获取到的window对象的属性和方法(html5中的postMessage方法是一个例外)，总之，你可以当做是只能获取到一个几乎无用的window对象。\ndocument.domain的设置是有限制的：\n我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\n　　例如：a.b.c.com 中某个文档的document.domain 可以设成a.b.c.com、b.c.com 、c.com中的任意一个\n3.使用window.name+iframe来进行跨域\nwindow的name属性特征：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB），即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面window.name都有读写的权限。\n4.使用window.postMessage方法来跨域(不常用)\nwindow.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源(可实现跨域)，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。\n\nmessage：为要发送的消息，类型只能为字符串；\ntargetOrigin：用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 “*”。\n\n创建www.test.com/a.html页面代码：\n12345678&lt;script&gt;function onLoad()&#123;    var iframe = document.getElementById(&quot;iframe&quot;);    var win = iframe.contentWindow;    win.postMessage(&#x27;哈哈，我是来自页面a.html的信息哟！&#x27;,&#x27;*&#x27;);//向不同域的www.script.com/b.html发送消息&#125;&lt;/script&gt;&lt;iframe id=&quot;iframe&quot; src=&quot;www.script.com/b.html&quot; onload=&quot;onLoad()&quot;&gt;&lt;/iframe&gt;\n创建www.script.com/b.html页面代码：\n123456 &lt;script&gt;window.onmessage = function(e)&#123;//注册message时间来接收消息   e = e || event;            //获取时间对象   alert(e.data);             //通过data属性来得到传送的消息&#125;&lt;/script&gt;\n5.使用跨域资源共享（CORS）来跨域\nCORS：一种跨域访问的机制，可以让AJAX实现跨域访问；CORS允许一个域上的网络应用向另一个域提交跨域AJAX请求。\n服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求．\n就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。\n6.使用Web sockets来跨域\nweb sockets： 是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)\nweb sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。\n1234567&lt;script&gt;var socket = new WebSockt(&#x27;ws://www.test.com&#x27;);//http-&gt;ws; https-&gt;wsssocket.send(&#x27;hello WebSockt&#x27;);socket.onmessage = function(event)&#123;    var data = event.data;&#125;\n","thumbnail":"https://i.loli.net/2021/09/05/XlSGQUqhDEmeaHR.jpg","plink":"http://example.com/2021/09/05/前端面试题（上）/"},{"title":"Hello World","date":"2021-09-04T09:45:23.950Z","date_formatted":{"ll":"2021年9月4日","L":"2021/09/04","MM-DD":"09-04"},"updated":"2021-09-05T03:07:38.075Z","content":"zhehsi biaoti\nhalou\nhhh\nsdasdasdas\n\n","thumbnail":"https://i.loli.net/2021/09/05/zisec2jqTflItr9.jpg","plink":"http://example.com/2021/09/04/hello-world/"},{"title":"about","date":"2021-09-05T02:52:37.000Z","date_formatted":{"ll":"2021年9月5日","L":"2021/09/05","MM-DD":"09-05"},"updated":"2021-09-05T02:56:25.421Z","content":"这是关于我的内容\n","plink":"http://example.com/about/"}]